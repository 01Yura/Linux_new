**Тестирование программного обеспечения (Software Testing)** — проверка соответствия реальных и ожидаемых результатов поведения программы, проводимая на конечном наборе тестов, выбранном определённым образом.

**Цель тестирования** — проверка соответствия ПО предъявляемым требованиям, обеспечение уверенности в качестве ПО, поиск очевидных ошибок в программном обеспечении, которые должны быть выявлены до того, как их обнаружат пользователи программы.

Для чего мы тестируем:
- проверка соответствия требованиям (ожидание - реальность)
- для обнаружения проблем на ранних этапах разработки (или при анализе требований от бизнес аналитика и системного аналитика)
- обнаружение вариантов использования не по прямому назначению
- повышение лояльности клиента к компании и продукту (любой негатив влияет на это)

                    QA/QC/Testing

**Обеспечение качества (QA — Quality Assurance)** и **контроль качества (QC — Quality Control)**
— эти термины похожи на взаимозаменяемые, но разница между обеспечением качества и контролем качества все-таки есть, хоть на практике процессы и имеют некоторую схожесть.

QA (Quality Assurance) — Обеспечение качества продукта — изучение возможностей по изменению и улучшению процесса разработки, улучшению коммуникаций в команде, где тестирование является только одним из аспектов обеспечения качества.
- проверка требований к ПО
- оценка рисков (какие могут возникнуть проблемы, что может пойти не так)
- планирование как улучшить качество продукта
- подготовка тестовой документации, тестового окружения
- тестирование
- анализ результатов тестирования

QC (Quality Control) — Контроль качества продукта — анализ результатов тестирования и качества новых версий выпускаемого продукта.
- проверка насколько ПО готово к релизу
- проверка соответствия требований и качества

Testing (тестирование) - прохождение по шагам по готовой тестовой документации, где уже есть ОР и мы лишь выставляем ФР

Принципы тестирования:
1. Тестирование демонстрирует наличие дефектов (благодаря чему мы можем снизить вероятность наличия деефектов, но не гарантирует их полного отсутствия)
2. Исчерпывающее тестирование не возможно (полное тестирование с использованием всех входных комбинаций и предусловий невоможно, за искл нек случаев)
3. Раннее тестирование (начинать тестирование при разработке ПО надо начинать как можно раньше) - shift left testing
4. Скопление дефектов (большая часть багов находится в ограниченном количестве модулей)
5. Парадокс Пестицида - если повторять одни и те же тесты снова и снова, то в какой-то момент этот набор тестов перестает выявлять новые баги
6. Тестирование зависит от контекста (например банковкое приложение тестируется иначе чем новостной портал)
7. Заблуждение об отсутствии ошибок (отсутствие багов, не всегда значит готовность ПО к релизу, система должна быть удобна и удовлетворять потребности пользователей)

                    Верификация и валидация

Верификация - это процесс проверки того, что наще ПО соответствует спецификациям, требованиям, документации (которая сформулирована еще в начале). Делаем ли мы продукт правильно?

Валидация - это процесс проверки того, соответствует ли конечный продукт ожиданиям и потребностям пользователей. Делаем ли мы правильный продукт?

Пример с посадкой аэробуса A310 и закрылками/кручение колес.

Документация бывает 
- Проэктная (описывает весь проэкт включая временные рамки, бюджет, людской ресурс, оборудование, этапы, сроки, риски)
- Продуктовая (это техническая спецификация, архитектура, взаимодействие компонетнов, руководсво пользователя, руководсво админа, API документация, руководсво по тестирования и развертыванию, FAQ )

                    Tребования

Требования - это спецификация (описание) того, что должно быть реализовано.
Без технических деталей

Атрибуты требований:
1 Полнота — в требовании должна содержаться вся необходимая для реализации функциональности информация.
8 Модифицируемость — в каждое требование можно внести изменение.
2 Корректность — точное описание разрабатываемого функционала.
3 Недвусмысленность — требование должно содержать однозначные формулировки.
4 Непротиворечивость — требование не должно содержать внутренних противоречий и противоречий другим требованиям и документам.
5 Проверяемость — формулировка требований таким образом, чтобы можно было выставить однозначный вердикт, выполнено все в соответствии с требованиями или нет.
6 Приоритетность — у каждого требования должен быть приоритет(количественная оценка степени значимости требования). Этот атрибут позволит грамотно управлять ресурсами на проекте.
7 Атомарность — требование нельзя разбить на отдельные части без потери деталей.
9 Прослеживаемость — каждое требование должно иметь уникальный идентификатор, по которому на него можно сослаться.

                        SDLC

SDLC (Software Development Life Cycle) - это жизненный цикл разработки программного обеспечения. Он представляет собой структурированный процесс, состоящий из различных фаз и этапов, которые выполняются при создании программного продукта.

1 Анализ и сбор требований: на этом этапе происходит определение и сбор требований к программному продукту. Проводится исследование, выявляются потребности пользователей и определяются функциональные и нефункциональные требования.
2 Проектирование: на этом этапе разрабатывается архитектура и дизайн программного продукта. Определяются компоненты системы, их взаимосвязи и интерфейсы.
3 Разработка: на этом этапе происходит непосредственная реализация программного продукта. Программисты пишут код, создают функциональность и выполняют тестирование единиц кода.
4 Тестирование: на этом этапе проводится тестирование программного продукта с целью выявления ошибок, дефектов и проверки его соответствия требованиям. Включает в себя функциональное тестирование, интеграционное тестирование, системное тестирование и другие виды тестирования.
5 Развёртывание: на этом этапе программный продукт готовится к выпуску и установке на целевой среде. Включает в себя подготовку документации, инсталляцию, настройку и обучение пользователей.
6 Эксплуатация и поддержка: после развёртывания программного продукта происходит его эксплуатация, поддержка и обновление. Ведется мониторинг работы системы, исправление ошибок и добавление новой функциональности.

                        STLC


STLC (Software Testing Life Cycle) - это жизненный цикл тестирования программного обеспечения. Он представляет собой структурированный процесс, состоящий из различных фаз и этапов, которые выполняются при проведении тестирования программного продукта.

1. Планирование: на этом этапе определяются цели тестирования, разрабатывается план тестирования и определяются ресурсы, необходимые для выполнения тестов.
2. Анализ требований и создание тестовой документации: на этом этапе изучаются требования к программному продукту и создается тестовая документация, включающая тестовые случаи, тестовые сценарии и другие артефакты.
3 Дизайн тестов: на этом этапе разрабатывается стратегия тестирования и определяются методы, подходы и техники, которые будут использоваться для проведения тестов. Создаются тестовые случаи и сценарии на основе требований и анализа продукта.
4 Подготовка к выполнению тестов: на этом этапе создается тестовая среда, включающая необходимые инструменты и данные для проведения тестов. Также выполняется подготовка тестовых сценариев и проверка настроек тестовой среды.
5 Выполнение тестов: на этом этапе проводятся тестирование по определенным тестовым случаям и сценариям. Результаты тестов регистрируются, ошибки и дефекты отслеживаются и отчеты о тестировании создаются.
6 Анализ результатов тестирования: на этом этапе происходит анализ результатов тестирования, выявление и регистрация дефектов. Оценивается качество продукта и принимаются решения о его готовности к выпуску.
7 Завершение: на этом этапе подводятся итоги тестирования, создается финальный отчет о выполненном тестировании, проводится оценка процесса тестирования и выявление возможных улучшений.

                        Severity vs Priority

    Severity (серьезность) - показывает степень ущерба, который наносится проекту существованием дефекта. Severity выставляется тестировщиком.
Стоит учесть что Серьезность применяется в основном к баг-репортам

Блокирующий (S1 – Blocker) - тестирование значительной части функциональности вообще недоступно. Блокирующая ошибка, приводящая приложение в нерабочее состояние, в результате которого дальнейшая работа с тестируемой системой или ее ключевыми функциями становится невозможна.

Критический (S2 – Critical) - критическая ошибка, неправильно работающая ключевая бизнес-логика, дыра в системе безопасности, проблема, приведшая к временному падению сервера или приводящая в нерабочее состояние некоторую часть системы, то есть не работает важная часть одной какой-либо функции либо не работает значительная часть, но имеется workaround (обходной путь/другие входные точки), позволяющий продолжить тестирование.

Значительный (S3 – Major) - не работает важная часть одной какой-либо функции/бизнес-логики, но при выполнении специфических условий, либо есть workaround, позволяющий продолжить ее тестирование либо не работает не очень значительная часть какой-либо функции. Также относится к дефектам с высокими visibility – обычно не сильно влияющие на функциональность дефекты дизайна, которые, однако, сразу бросаются в глаза.

Незначительный (S4 – Minor) - часто ошибки GUI, которые не влияют на функциональность, но портят юзабилити или внешний вид. Также незначительные функциональные дефекты, либо которые воспроизводятся на определенном устройстве.

Тривиальный (S5 – Trivial) - почти всегда дефекты на GUI — опечатки в тексте, несоответствие шрифта и оттенка и т.п., либо плохо воспроизводимая ошибка, не касающаяся бизнес-логики, проблема сторонних библиотек или сервисов, проблема, не оказывающая никакого влияния на общее качество продукта

    Срочность (priority) - показывает, как быстро дефект должен быть устранён. Priority выставляется менеджером, тимлидом или заказчиком

P1 Высокий (High) - Критическая для проекта ошибка. Должна быть исправлена как можно быстрее.
P2 Средний (Medium) - Не критичная для проекта ошибка, однако требует обязательного решения.
P3 Низкий (Low) - Наличие данной ошибки не является критичным и не требует срочного решения. Может быть исправлена, когда у команды появится время на ее устранение.

                   Пирамида тестирования

Это группировка тестов по уровню детализации и назначению
4 уровня: (снизу вверх)
   
    - Модульное тестирование (юнит-тестирование) компонентный уровень
Всегда автоматизируют, им обычно занимается разраб, этих тестов больше, они выполняются быстрее всех и требуют меньше ресурсов, и они не зависят от других модулей (н-р в калькуляторе тестируем функцию сложение, которая не зависит от умножения)
Тут используется метод белого ящика
Unit-тесты занимают основное место в пирамиде, так как они:
1 Наименее затратные по времени и ресурсам.
2 Проверяют отдельные компоненты, что позволяет быстро обнаруживать и устранять ошибки в них.
Модульное тестировпнре подращумевает доступ к коду и его понимание. Обычный тестер не делает можкльное тестировпние, так как не шарит в коде. Но не надо путать модульное тестирование как уровень и темтирование отдельных модулей. Мы можем тестировать отдельные модули.
В 99% разработкой модульных тестов занимается разработчик, при нахождении ошибки на этом уровне не создается баг-репортов. Разработчик находит баг, правит, запускает и проверяет (абстрактно говоря это разработка через тестирование) и так по новой, пока тест не будет пройден успешно.


    - Интеграционное тестирование
Проверят взаимосвязь компоненты, которую проверяли на модульном уровне, с другой или другими компонентами, а также интеграцию компоненты с системой (проверка работы с ОС, сервисами и службами, базами данных, железом и т.д.). Часто в английских статьях называют service test или API test.
Компоненты ПО или системы взаимодействуют с тестируемым модулем с помощью интерфейсов. Это проверки API, работы сервисов (проверка логов на сервере, записи в БД) и т.п. Отдельно отмечу, что в интеграционном тестировании, выполняются как функциональные (проверка по ТЗ), так и нефункциональные проверки (нагрузка на связку компонент). На этом уровне используется либо серый, либо черный ящик.
Имеют более высокий уровень абстракции и сложности, чем Unit-тесты, поэтому их меньше, но они все еще затратны.

В интеграционном тестировании есть 3 основных способа тестирования:
    1 Снизу вверх (Bottom Up Integration): все мелкие части модуля собираются в один модуль и тестируются. Далее собираются следующие мелкие модули в один большой и тестируется с предыдущим и т.д. Например, функция публикации фото в соц. профиле состоит из 2 модулей: загрузчик и публикатор. Загрузчик, в свою очередь, состоит из модуля компрессии и отправки на сервер. Публикатор состоит из верификатора (проверяет подлинность) и управления доступом к фотографии. В интеграционном тестировании соберем модули загрузчика и проверим, потом соберем модули публикатора, проверим и протестируем взаимодействие загрузчика и публикатор.

    2 Сверху вниз (Top Down Integration): сначала проверяем работу крупных модулей, спускаясь ниже добавляем модули уровнем ниже. На этапе проверки уровней выше данные, необходимые от уровней ниже, симулируются.Например, проверяем работу загрузчика и публикатора. Руками (создаем функцию-заглушку) передаем от загрузчика публикатору фото, которое якобы было обработано компрессором.

    3 Большой взрыв ("Big Bang" Integration): собираем все реализованные модули всех уровней, интегрируем в систему и тестируем. Если что-то не работает или недоработали, то фиксим или дорабатываем.

    - Системное тестирование
Системный уровень проверят взаимодействие тестируемого ПО с системой по функциональным и нефункциональным требованиям.
Важно тестировать на максимально приближенном окружении, которое будет у конечного пользователя.
На системном уровне выявляются такие дефекты, как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д.
На этом уровне используют черный ящик. Интеграционный уровень позволяет верифицировать требования (проверить соответствие ПО прописанным требованиям).
    
    - Приемочное тестирование
Также часто называют E2E тестами (End-2-End) или сквозными. На этом уровне происходит валидация требований (проверка работы ПО в целом, не только по прописанным требованиям, что проверили на системном уровне).
Проверка требований производится на наборе приемочных тестов. Они разрабатываются на основе требований и возможных способах использования ПО.
Отмечу, что приемочные тесты проводят, когда (1) продукт достиг необходимо уровня качества и (2) заказчик ПО ознакомлен с планом приемки (в нем описан набор сценариев и тестов, дата проведения и т.п.).
Проверяют приложение на уровне пользователя, оценивая его работу в реальных условиях.
Более медленные и затратные, так как они эмулируют действия пользователя на более высоком уровне.

                        Техника тест-дизайна 

Техника тест-дизайна - это систематический подход к планированию, созданию и выбору тестовых случаев и данных для тестирования программного обеспечения с использованием определенных методов и стратегий

Техника тест-дизайна - это набор методов и инструментов, используемых для разработки тестовых случаев на основе заранее определенных критериев и анализа требований. Она позволяет структурировать и оптимизировать процесс тестирования, обеспечивая максимальное покрытие функциональности и возможных сценариев использования программного продукта.

1 Увеличение покрытия тестирования: Техники тест-дизайна помогают создавать тесты, которые охватывают различные аспекты программного обеспечения, включая различные варианты использования и возможные ошибки.
2 Эффективное использование ресурсов: Позволяют оптимизировать количество тестовых случаев и ресурсы, необходимые для тестирования, снижая издержки и ускоряя процесс разработки.
3 Повышение качества программного обеспечения: Создание более полного и эффективного плана тестирования способствует выявлению ошибок и недочетов в ранние стадии разработки, что помогает улучшить качество программы и снизить вероятность возникновения проблем после выпуска в эксплуатацию.

    Эквивалентное разделение

Эквивалентное разделение подразумевает разбиение тестовых данных на классы по какому-то признаку. 
Если мы выбираем в качестве техники тест-дизайна эквивалентное разделение, это означает, что мы будем тестировать только несколько значений из каждого класса элементов. Помните, что это не гарантирует отсутствия ошибок в остальных значениях, не охваченных тестами. Мы лишь предполагаем, что использование нескольких элементов из каждой группы будет достаточно показательным.
Эквивалентное разделение — хорошее решение для случаев, когда вы имеете дело с большим объемом входящих данных или множеством одинаковых вариантов ввода. В противном случае, возможно, имеет смысл более тщательно охватить продукт тестами.

    Анализ граничных значений

Анализ граничных значений в чем-то похож на эквивалентное разделение. Можно даже сказать, что оно лежит в основе эквивалентном разбиении. Но есть некоторые отличия.
При анализе граничных значений мы тоже группируем данные по эквивалентным классам, но проверяем не значения из определенного класса, а граничные значения — те, которые находятся на «границах» классов.

    Переход состояний

Диаграмма перехода состояний визуализирует состояния программы в разные периоды времени и на разных этапах использования. Визуальную информацию воспринимать проще, чем текст. Таким образом, техника перехода состояний позволяет быстрее получить максимальное тестовое покрытие.
Допустим, мы тестируем систему, которая предлагает ограниченное количество попыток ввести правильный пароль. Если пользователь не введет правильный пароль 3 раза, система блокирует доступ (временно или постоянно).

    Попарное тестирование

Попарное тестирование основано на математических алгоритмах, а именно на комбинаторике. Оно позволяет создавать уникальные пары и тестировать огромное количество поступающих данных в разных сочетаниях, но расчеты могут быть сложными.
Чтобы охватить тестовыми сценариями максимум фич и при этом потратить минимальное время на тестирование, нужно правильно сопоставлять данные, комбинируя пары определенным образом на основе расчетов.

                        Виды тестирование (классификация)

1. Классификация по запуску кода на исполнение:
- Статическое тестирование — процесс тестирования, который проводится для верификации практически любого артефакта разработки (любое документальное, программное или техническое средство, созданное или используемое в процессе разработки): программного кода компонент, требований, системных спецификаций, функциональных спецификаций, документов проектирования и архитектуры программных систем и их компонентов. Проводится без запуска програмного кода приложения
- Динамическое тестирование — тестирование проводится на работающей системе, не может быть осуществлено без запуска программного кода приложения. 

2. Классификация по доступу к коду и архитектуре:
- Тестирование белого ящика — метод тестирования ПО, который предполагает полный доступ к коду проекта.
- Тестирование серого ящика — метод тестирования ПО, который предполагает частичный доступ к коду проекта (комбинация White Box и Black Box методов).
- Тестирование чёрного ящика — метод тестирования ПО, который не предполагает доступа (полного или частичного) к системе. Основывается на работе исключительно с внешним интерфейсом тестируемой системы.

3. Классификация по уровню детализации приложения:
- Модульное тестирование — проводится для тестирования какого-либо одного логически выделенного и изолированного элемента (модуля) системы в коде (то есть небольшой изолированной части кода, обычно функции или метода). Проводится самими разработчиками, так как предполагает полный доступ к коду. Обычно автоматизируются. 
- Интеграционное тестирование — тестирование, направленное на проверку корректности взаимодействия нескольких модулей, объединенных в единое целое.
- Системное тестирование — процесс тестирования системы, на котором проводится не только функциональное тестирование, но и оценка характеристик качества системы — ее устойчивости, надежности, безопасности и производительности.
- Приёмочное тестирование — проверяет соответствие системы потребностям, требованиям и бизнес-процессам пользователя.

4. Классификация по степени автоматизации:
- Ручное тестирование
- Автоматизированное тестирование

5. Классификация по принципам работы с приложением
- Позитивное тестирование — тестирование, при котором используются только корректные данные.
- Негативное тестирование — тестирование приложения, при котором используются некорректные данные и выполняются некорректные операции.

6. Классификация по уровню функционального тестирования:
- Дымовое тестирование (smoke test) — тестирование, выполняемое на новой сборке, с целью подтверждения того, что программное обеспечение стартует и выполняет основные для бизнеса функции.
- Тестирование критического пути (critical path) — направлено для проверки функциональности, используемой обычными пользователями во время их повседневной деятельности.
- Расширенное тестирование (extended) — направлено на исследование всей заявленной в требованиях функциональности.
- Проверочное тестирование (sanity test) - тестирование новой фичи, или определенной части системы, которая была добавлена или переработана.
- Регрессионное тестирование (регресс, regression testing) - повторное тестирование системы после внесения изменений, чтобы убедится, что новые фичи не нарушили существующую функциональность. 

Например есть 1000 тестов. 100 это smoke, 600-700 это sanity, 200 regression

7. Классификация в зависимости от исполнителей:
- Альфа-тестирование — является ранней версией программного продукта. Может выполняться внутри организации-разработчика с возможным частичным привлечением конечных пользователей.
- Бета-тестирование — программное обеспечение, выпускаемое для ограниченного количества пользователей. Главная цель — получить отзывы клиентов о продукте и внести соответствующие изменения.

8. Классификация в зависимости от целей тестирования:
- Функциональное тестирование (functional testing) — направлено на проверку корректности работы функциональности приложения.
- Нефункциональное тестирование (non-functional testing) — тестирование атрибутов компонента или системы, не относящихся к функциональности.
    - Тестирование производительности (performance testing) — определение стабильности и потребления ресурсов в условиях различных сценариев использования и нагрузок.
    - Нагрузочное тестирование (load testing) — определение или сбор показателей производительности и времени отклика программно-технической системы или устройства в ответ на внешний запрос с целью установления соответствия требованиям, предъявляемым к данной системе (устройству).
    - Тестирование масштабируемости (scalability testing) — тестирование, которое измеряет производительность сети или системы, когда количество пользовательских запросов увеличивается или уменьшается.
    - Стрессовое тестирование (stress testing) — тип тестирования направленный для проверки, как система обращается с нарастающей нагрузкой (количеством одновременных пользователей).
    - Инсталляционное тестирование (installation testing) — тестирование, направленное на проверку успешной установки и настройки, обновления или удаления приложения.
    - Тестирование интерфейса (GUI/UI testing) — проверка требований к пользовательскому интерфейсу.
    - Тестирование удобства использования (usability testing) — это метод тестирования, направленный на установление степени удобства использования, понятности и привлекательности для пользователей разрабатываемого продукта в контексте заданных условий.
    - Тестирование локализации (localization testing) — проверка адаптации программного обеспечения для определенной аудитории в соответствии с ее культурными особенностями.
    - Тестирование безопасности (security testing) — это стратегия тестирования, используемая для проверки безопасности системы, а также для анализа рисков, связанных с обеспечением целостного подхода к защите приложения, атак хакеров, вирусов, несанкционированного доступа к конфиденциальным данным.
    - Регрессионное тестирование (regression testing) — тестирование уже проверенной ранее функциональности после внесения изменений в код приложения, для уверенности в том, что эти изменения не внесли ошибки в областях, которые не подверглись изменениям.
    - Повторное/подтверждающее тестирование (re-testing/confirmation testing) — тестирование, во время которого исполняются тестовые сценарии, выявившие ошибки во время последнего запуска, для подтверждения успешности исправления этих ошибок.




                            AGILE
Это методология (философия) управления разработкой, подчиняющаяся определеным принципам, озвученным в манифесте.                           
2001 год, США, штат Юта, группа из 17 разработчиков и глыб индустрии собралась вместе и родила AGILE манифест:

Люди и их взаимодействие важнее процессов и инструментов.
Работающий продукт важнее исчерпывающей документации.
Сотрудничество с заказчиком важнее согласования условий контракта.
Готовность к изменениям важнее следования плану.

                            SCRUM

Scrum — это методика гибкого управления проектами, помогающая командам структурировать работу и управлять ею на основе определенного набора ценностей, принципов и практик. Agile это философия, а scrum - это практическая методика работы, фреймворк если хотите.

Состав scrum-команды предполагает три конкретные роли: владелец продукта, scrum-мастер и команда разработчиков
Владелец продукта:
- они составляют бэклог продукта и управляют им., ПРИОРИТИЗИРУЕТ бэклог
- они тесно сотрудничают с руководством компании и командой, сообщая каждому участнику значение рабочих задач в бэклоге продукта.
- они дают команде понятные указания, чтобы ее участники знали, какие возможности поставить следующими.
- они решают, когда поставить продукт, стремясь делать это как можно чаще.
Scrum-мастер: (это может быть один человек - PM)
    Scrum-мастера следят за применением принципов Scrum в своих командах. Они обучают команды, владельцев продуктов и остальную компанию тонкостям scrum-процесса и стараются оптимизировать применение этой практики.
Команда разработчиков:
    Чтобы определить размер команды, можно обратиться к известному «правилу двух пицц», которое сформулировал глава Amazon Джефф Безос: в команде должно быть столько участников, чтобы им хватало двух пицц. То есть 5-7чел.
    Все участники команды помогают друг другу, чтобы успешно завершить спринт.

                        Артефакты Scrum

Артефакты Scrum — это важная информация, используемая scrum-командой для описания продукта и работ, которые необходимо выполнить для его создания. В Scrum есть три артефакта: бэклог продукта, бэклог спринта и инкремент с вашими критериями готовности. Это три константы, над которыми scrum-команда должна размышлять во время спринтов и с течением времени.    

Бэклог продукта — это главный список задач, которые необходимо выполнить. Его ведет владелец либо менеджер продукта. Это постоянно меняющийся перечень функциональных возможностей, требований, улучшений и исправлений, из которого берутся задачи для бэклога спринта. По сути, это список задач команды. Владелец продукта регулярно просматривает бэклог продукта, меняет в нем приоритеты и поддерживает его актуальность по мере появления новой информации или изменений на рынке, в связи с которыми отдельные задачи утрачивают смысл или возникают новые способы решения проблем.

Бэклог спринта — это список рабочих задач, пользовательских историй или исправлений багов, отобранных командой разработчиков для реализации в текущем цикле спринта. Перед каждым спринтом проводится собрание по планированию спринта (его мы обсудим далее в статье), на котором команда выбирает, какие задачи из бэклога продукта нужно выполнить в рамках спринта. Бэклог спринта может не быть фиксированным и может меняться по ходу спринта. Однако ничто не должно мешать достижению основной цели спринта — того, чего команда хочет добиться за текущий спринт.

Инкремент (или цель спринта) — это готовый к использованию конечный продукт по итогам спринта. В компании Atlassian принято представлять инкремент на демонстрации в конце спринта, на которой команда показывает, что она сделала за спринт.

Перечислим основные собрания, в которых может принять участие команда Scrum:

- Организация бэклога. За это мероприятие, также известное как ведение бэклога, несет ответственность владелец продукта

- Планирование спринта. На этом собрании команда разработчиков под руководством scrum-мастера планирует работу (объем спринта), которую необходимо выполнить в течение текущего спринта. В конце собрания по планированию каждый участник команды Scrum должен четко представлять, какие задачи можно выполнить за спринт и как поставить инкремент.Тут происходит покер планирование в story points.

- Спринт. Спринт — это фактический промежуток времени, в течение которого команда Scrum совместно работает над созданием готового инкремента. Как правило, спринт длится две недели, хотя некоторым командам проще спланировать объем спринта на одну неделю или поставить инкремент, обладающий достаточной ценностью, за месяц. В течение этого периода владелец продукта и команда разработчиков могут пересмотреть объем спринта, если это необходимо. Это и есть ключ к пониманию эмпирической сути Scrum.
- Ежедневное scrum-совещание, или стендап (дейлик). Это очень быстрое ежедневное совещание, которое проводится в одно и то же время (обычно утром) в стиле «коротко и по делу». Многие команды стараются уложиться в 15 минут, однако это лишь рекомендация.
Стендап — подходящее время сообщить обо всем, что мешает вам достичь цели спринта, в том числе о блокерах.
Чаще всего в рамках стендапа каждому участнику команды предлагается ответить на следующие три вопроса, связанные с достижением цели спринта:
• Что мне удалось сделать вчера?
• Что я планирую сделать сегодня?
• Может ли мне что-то помешать?

- Обзор итогов спринта (sprint review) (демо). В конце спринта команда собирается для просмотра демонстрации инкремента (или для его изучения) в неформальной обстановке. Разработчики представляют заинтересованным сторонам (стейкхолдеры) и коллегам завершенные рабочие задачи из бэклога, чтобы собрать отзывы. Владелец продукта решает, стоит ли выпускать инкремент, хотя в большинстве случаев команда получает зеленый свет.

- Ретроспектива спринта. Ретроспектива проводится, чтобы команда зафиксировала и обсудила все успехи и неудачи спринта, проекта, участников и их взаимоотношений, инструментов или даже определенных собраний. Цель ретроспективы — создать условия, чтобы команда могла уделить внимание всему, что удалось и что нужно улучшить в следующий раз, и не зацикливалась на неудачах.

                        Тестовая документация

    Тест-план

Тест-план (Test Plan) представляет собой документ, в котором описан весь объем работ по тестированию, начиная с определения объекта тестирования и стратегии, заканчивая расписанием, критериями начала и окончания тестирования, а также необходимым оборудованием, специализированными знаниями и анализом рисков с возможными путями их разрешения.

Что включает в себя тест-план:

Название:
Объект тестирования: Полное описание того, что будет тестироваться. Это может быть приложение, веб-сайт, программное обеспечение и другие компоненты.
Стратегия тестирования: Определяет методы и подход к тестированию, включая ресурсы и время, необходимые для каждой фазы тестирования.
Тест-процедуры: Подробные инструкции, описывающие шаги для настройки, выполнения и оценки результатов теста.
Критерии начала и окончания тестирования: Условия, которые должны быть выполнены, чтобы начать и завершить тестирование. Они определяют готовность продукта к релизу.
Ресурсы для тестирования: Определяют необходимые ресурсы, включая персонал, среды тестирования, оборудование и инструменты.
Предварительные условия: Описывают состояние системы и ее окружение, которые необходимы для успешного тестирования.
Оценка рисков: Идентификация потенциальных проблем и способы их устранения для обеспечения успешного завершения тестирования.

Этот документ помогает всем участникам тестирования иметь общее представление о целях, процессе и требованиях для достижения успешного завершения тестирования продукта.

    Тест-кейс

Тест-кейс (Test case) — пошаговое описание действий, которые нужно произвести для проверки какой-либо функции ПО.
**КАЖДЫЙ ТЕСТ-КЕЙС АТОМАРЕН И ПРОВЕРЯЕТ ТОЛЬКО 1 ДЕЙСТВИЕ.**
Простыми словами, это алгоритм, по которому тестировщик должен пройти (смоделировать поведение пользователя), чтобы проверить работоспособность определенного куска кода.

ID теста: 001
Название: Проверка входа на сайт с корректной парой логин/пароль.
Предусловия: Нет.
Шаги выполнения:	
    1. Откройте страницу сайта.
    2. На сайте вверху справа нажмите кнопку «Войти», дождитесь появления формы.
    3. В поле «Логин» введите «Тестеры», а в поле «Пароль» введите «NeverSleep», затем ниже нажмите кнопку «Войти».
Ожидаемый результат: На экране отображается профиль (личный кабинет) пользователя «Тестеры».
Постусловие: Нажать кнопку «Выход», чтобы выйти из системы.

Виды тест-кейсов:
- положительный
- орицательные
- деструктивные

Основная разница между чек-листом и тест-кейсом заключается в том, что чек-лист содержит список задач, которые нужно выполнить, а тест-кейс содержит детализированные шаги для выполнения каждой задачи.

    Баг-репорт

Отчет о дефекте (defect report, bug report) – это документ, содержащий отчет о любом недостатке в программном обеспечении, системе или ее компоненте.

Отличие дефекта от ошибки:

Основное отличие между дефектом и ошибкой заключается в контексте их возникновения. Дефект обычно относится к неправильному поведению или в программном коде или системе, которое обнаруживается в процессе тестирования или эксплуатации. Ошибка, в свою очередь, относится к неправильным действиям разработчиков или пользователей, приводящим к появлению дефекта. Таким образом, ошибка является причиной, а дефект — следствием.

Классификация по серьезности:

Blocker
	Баги, препятствующие дальнейшему тестированию или эксплуатации продукта. Примеры включают сбои системы, потерю данных или другие критические проблемы, которые полностью блокируют использование функционала.
	
Пример: Приложение для онлайн-шопинга аварийно завершает работу при попытке добавить товар в корзину. Этот баг полностью блокирует возможность совершения покупок, делая основную функцию приложения недоступной для пользователей.

Critical
	Серьезные дефекты, нарушающие основную бизнес-логику или функциональность продукта. Не вызывают полного сбоя системы, но могут серьезно повлиять на производительность или безопасность.
	
Пример: Система интернет-банкинга не проводит операции по переводу денег, выдавая ошибку обработки транзакции. Хотя приложение остается работоспособным, критический функционал, такой как перевод средств, недоступен.

Major
	Баги, влияющие на работу отдельных функций, несмотря на то, что основные процессы остаются работоспособными. Могут вызвать неудобства для пользователей или незначительно снизить производительность.
	
Пример: Функция поиска на сайте электронной коммерции возвращает неактуальные или нерелевантные результаты. Пользователи все еще могут искать и покупать товары, но их опыт работы с сайтом существенно ухудшается из-за проблем с поиском.

Minor
	Мелкие проблемы, которые влияют на удобство использования или внешний вид приложения, но не затрагивают его основную функциональность.
	
Пример: Некорректное отображение формата даты в пользовательском профиле на сайте. Данный баг не влияет на функциональность сайта и может быть легко исправлен без срочного вмешательства.

Trivial	
    Самые мелкие недочеты, такие как опечатки, небольшие проблемы с форматированием интерфейса, которые почти не влияют на пользовательский опыт.
	
Пример: Опечатка в тексте кнопки на главной странице приложения ("Зарегестрироваться" вместо "Зарегистрироваться"). Это не влияет на функциональность или производительность приложения, но может негативно сказаться на восприятии профессионализма разработчиков.


Классификация по приоритетности:

High
	Баги, требующие немедленного исправления, поскольку они могут оказать значительное негативное влияние на пользовательский опыт, безопасность или критические бизнес-процессы.
	
Пример: Веб-сайт онлайн-магазина не шифрует пользовательские данные при отправке формы регистрации. Этот баг представляет собой серьезную угрозу безопасности, позволяя потенциальным злоумышленникам перехватывать конфиденциальную информацию, такую как пароли и номера кредитных карт. Исправление этой уязвимости является высоким приоритетом, чтобы защитить пользователей и соответствовать стандартам безопасности.

Medium
	Баги, которые следует исправить в ближайших релизах, поскольку они влияют на функциональность или удобство использования продукта, но не критичны для его основной работы.
	
Пример: Функция фильтрации на странице продуктов интернет-магазина работает некорректно, не позволяя пользователям эффективно сортировать товары по цене. Хотя это не мешает основным операциям покупки, оно снижает удобство использования сайта и может оттолкнуть клиентов. Исправление этого бага важно для улучшения пользовательского опыта, но не является срочным.

Low
	Недочеты, исправление которых может быть отложено без значительного вреда для проекта, такие как мелкие визуальные проблемы или улучшения, не влияющие на текущее использование продукта.
	
Пример: Визуальное несоответствие цветов кнопок в мобильном приложении с общим стилем бренда. Хотя это может влиять на эстетическую сторону приложения, функциональность остается неповрежденной. Исправление таких визуальных несоответствий имеет низкий приоритет и может быть отложено до следующего цикла обновления дизайна.



                           
                        DEV TOOLS
https://www.youtube.com/playlist?list=PLoZfdp36DZcqq6PoJJVHlS_c_1G89bkh7 - курс по тестированию

Лучше пользоваться в Хроме (так как 90% людей пользуются браузерами на основе движка Blink), но некоторые функции есть только в Firefox

Движки рендеринга страниц:
Blink (Chromium)
    Используется в браузерах Google Chrome, Microsoft Edge (до этого использовал собственный EdgeHTML, в 2020 перешел на Блинк) (версия на основе проекта Chromium), Opera.
    Разработан компанией Google и основан на проекте Chromium. Является forkом Apple WebKit
WebKit
    Используется в браузере Safari на устройствах Apple (macOS, iOS).
    Разработан компанией Apple на базе открытого проекта WebKit.
Gecko
    Используется в браузере Mozilla Firefox, TOR
    Разработан Фондом Mozilla.

CTRL + SHIFT + P - команданая строка
CTRL + SHIFT + K - открыть консоль в браузере
document.getElementsByTagName("video")[0].playbackRate = 2.25; - можно установить скорость видео введя это в консоли

                        Запрос регистрации на сайте по шагам

1) В браузере мы заполняем поле имя, мыло и пароль и нажимаем ОТПРАВИТЬ
1.1) Фронт клиента ро хорошему проверяет валидацию (имя не пустое, мыло соответствует, пароль надежный)
2) Клиент (наш браузер) отправляет HTTP request на сервер
3) Сервер, получив запрос, так же проверяет валидацию и отправляет запрос в БД, спрашивая "Есть ли уже такой пользователь (e-mail)?"
4) БД говорит - нет
4.1) Сервер хэширует пароль, иногда добавляя соль
5) Сервак отсылает POST request - запиши данный в браузер БД, создав юзера
6) БД отвечает серверу, что она сохранила данные
7) Сервер отсылает клиенту response - 200 OK
Может еще присутствовать какая то логика, типо валидация через e-mail (надо подтвердить и нажать на кнопку ПОДТВЕРДИТЬ в письме от сервиса) и др

Токен доступа (Access Token) - это специальная строка, которая предоставляет субъекту (например, пользователю или приложению) доступ к ресурсам на сервере после успешной аутентификации и авторизации. Токены доступа широко используются в системах аутентификации и авторизации для обеспечения безопасного доступа к ресурсам. 
Токен доступа действителен в течение определенного периода времени, после чего он должен быть обновлен (в случае использования Refresh Token) или повторно запрошен.

Существует несколько видов токенов доступа, и их использование может зависеть от протокола аутентификации. Некоторые из распространенных видов токенов включают:

Basic Authentication (базовая аутентификация) в HTTP ( БЕЗ ТОКЕНА) - это метод аутентификации, при котором браузер или клиент передает учетные данные пользователя (имя пользователя и пароль) в заголовке HTTP-запроса. Эти данные передаются в виде строки, закодированной в Base64, и помещаются в заголовок Authorization.
Basic Authentication передает учетные данные в незашифрованном виде (после кодирования в Base64, что не является шифрованием), поэтому он должен использоваться только через защищенное соединение (HTTPS) для предотвращения перехвата данных.
Учетные данные передаются при каждом запросе, что может повысить риск утечек. ТОКЕН не генерируется!
В Basic Authentication нет такого понятия, как "токен", который генерируется сервером. В Basic Auth клиент передает свои учетные данные (логин и пароль) в каждом запросе, закодированные в Base64. Эти данные просто прикрепляются к заголовку Authorization в каждом запросе.
Basic Authentication используется в случаях, когда требуется простая и быстрая аутентификация

Шаги аутентификации с использованием JWT или Bearer Token:

- Клиент отправляет учетные данные для аутентификации:
Клиент формирует POST запрос с логином и паролем в теле запроса.
{
"username": "user",
"password": "password"
}

- Сервер аутентифицирует клиента и выдает токен:
Сервер проверяет учетные данные и, если они корректны, генерирует токен (например, JWT) и возвращает его клиенту в теле ответа (token:value)
{
"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

- Клиент сохраняет токен:
Клиент сохраняет полученный токен (например, в local storage или cookies).

- Клиент использует токен для доступа к защищенным ресурсам:
При каждом последующем запросе клиент добавляет токен в заголовок Authorization с типом Bearer.
GET /protected-resource HTTP/1.1
Host: example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

Этот подход более безопасен, чем передача логина и пароля в заголовке Authorization, так как токен можно настроить на истечение через определенное время и легко отозвать, если это необходимо.

    JSON Web Token
JWT (JSON Web Token):  Он состоит из трех частей: заголовка (header), полезной нагрузки (payload) и подписи (signature).
Структура: JWT выглядит как три строки, разделенные точками: header.payload.signature.

    Bearer Token:
Что это: Bearer Token - это токен доступа, который используется в HTTP-заголовке Authorization для доступа к защищенным ресурсам. Он называется "Bearer" (носитель), потому что клиент предъявляет этот токен серверу как доказательство своей аутентификации.
Использование: Bearer Token - это тип токена, который может быть любым токеном, который клиент предоставляет для доступа к ресурсу. В контексте современных веб-приложений, Bearer Token часто представляет собой JWT.

    Связь между JWT и Bearer Token:
JWT как Bearer Token: JWT часто используется в качестве Bearer Token. Когда сервер выдает клиенту JWT, клиент сохраняет этот токен и использует его для доступа к защищенным ресурсам, передавая его в заголовке Authorization с типом Bearer.

    Основные отличия:
JWT: Это формат токена, который включает в себя информацию и подпись.
Bearer Token: Это способ передачи токена в HTTP-запросе. JWT часто используется в качестве Bearer Token, но Bearer Token не обязательно должен быть JWT.

Таким образом, JWT - это конкретный формат токена, а Bearer Token - это способ его использования для аутентификации в HTTP-запросах.

    OAuth 2.0
OAuth 2.0 (оу-ауф или open authorization) токены: В рамках протокола OAuth 2.0 могут использоваться различные виды токенов, такие как Bearer Token/access token (токен-носитель), Refresh Token (токен обновления), и др. 

Схема использования у токенов следующая:

Пользователь логинится в приложении, передавая логин и пароль на сервер. Они не сохраняются на устройстве, а сервер возвращает два токена и время их жизни
Приложение сохраняет токены и использует access token для последующих запросов. Access token передается в http заголовке Authorization с типом Bearer.
Когда время жизни access token подходит к концу (приложение может само проверять время жизни, или дождаться пока во время очередного использования сервер ответит «ой, всё»), приложение использует refresh token, чтобы обновить оба токена и продолжить использовать новый access token. Refresh token очень часто это обычная строка.

Зачем на самом деле нужен второй токен

Все оказалось и проще, и сложнее чем я думал. Следите за руками:

Случай 1: Боб узнал оба токена Алисы и не воспользовался refresh
В этом случае Боб получит доступ к сервису на время жизни access token. Как только оно истечет и приложение, которым пользуется Алиса, воспользуется refresh token, сервер вернет новую пару токенов, а те, что узнал Боб, превратятся в тыкву.

Случай 2: Боб узнал оба токена Алисы и воспользовался refresh
В этом случае оба токена Алисы превращаются в тыкву, приложение предлагает ей авторизоваться логином и паролем, сервер возвращает новую пару токенов, а те, что узнал Боб, снова превратятся в тыкву (тут есть нюанс с device id, может вернуть ту же пару что и у Боба. В таком случае следующее использование refresh токена превратит токены Боба в то, что изображено справа).

Таким образом, схема refresh + access токен ограничивает время, на которое атакующий может получить доступ к сервису. По сравнению с одним токеном, которым злоумышленник может пользоваться неделями и никто об этом не узнает.

API-ключи: В некоторых случаях вместо токенов могут использоваться API-ключи для аутентификации и авторизации запросов к API.

Способы передачи API-ключа:
- В заголовке HTTP
- В параметрах URL (Менее безопасный способ, так как ключ может быть виден в журналах серверов и истории браузера)
- В теле запроса


Общий сценарий работы с токеном доступа:

Аутентификация:
    Пользователь взаимодействует с клиентской частью системы (например, вводит логин и пароль в веб-форму).
    Клиент отправляет учетные данные на сервер для аутентификации.

Генерация токена:
    После успешной аутентификации сервер создает токен доступа.
    Токен может содержать информацию о пользователе, разрешениях (правах), сроке действия и других метаданных.

Передача токена клиенту:
    Сервер отправляет токен обратно клиенту, который сохраняет его локально (например, в cookie, localStorage или в памяти приложения).

Использование токена:
    Клиент включает токен в каждый запрос к защищенным ресурсам, например, в заголовке Authorization.
    Сервер проверяет валидность токена при каждом запросе.

Авторизация:
    Сервер использует информацию в токене для определения разрешений пользователя и принятия решения о предоставлении или отказе в доступе к определенным ресурсам.

Обновление токена (при необходимости):
    Если токен имеет ограниченный срок действия, клиент может обновить его, используя механизм обновления токена (например, Refresh Token).

                        Запрос входа (login) - когда юзер есть в БД

1) На клиенте (браузер) вводим мыло и пароль и отправляем запрос на сервер
2) Сервак стучится в БД (У тебя есть пользователь, зареганый по этому мылу?) и БД отдает ему пользователя по мылу, отсылая серверу имя, мыло и хэш пароля
3) Сервак проверяет соответствие хэшей паролей
4) Сервак отсылает нам токен авторизации (response with auth token) 
5) Клиент сохраняет этот токен в например local storage в формате например JSON ключ:значение
6) Токен может создаваться по-разному, выдаваться на определенное время (через 2 часа зайдешь на сайт и сайи поросит еще раз залогиниться)
7) Далее при запросах на сервак нужно прикреплять к запросу данный токен
8) Например я отправляю запрос получить список сохраненных товаров моей корзины с ценами и описанием (GET)
9) Сервак проверяет токен и если он совпадает, то спрашивает БД эту инфу
10) БД отпаляет инфу серверу, а сервер нам

Это простые схемы клиент-серверного взаимодействия, помимо сервера и БД могут быть балансировщики нагрузки, автомасштабирование (K8s), сервера кэширования, отдельно сервера аутентификации, бизнес-логики и тд

QUIC (quick UDP internet connection) - надстройка над UDP от Google. Использует шифрование и мультиплексирование.

                        HTTP

HTTP (hypertext transfer protocol) - протокол это набор правил и договоренностей
Первоначально служил для передачи гипертекстовых документов в формате HTML (hypertext Markup Language) - язык разметки гипертекста. 
Гипертекст - это текст со ссылками, нажав на которую переходишь на др документ
Элемент HTML включает тэг, его атрибуты и содержимое

Любой U(uniform)RL является URI, но не любой URI является URL (есть еще URN). Таким образом URL это частный случай URI.
URN - например urn:IETF:RFC:2616 (описывает HTTP 1й версии)
RFC 1918 - описывает приватные IP адреса    
    
    
    HTTP methods

GET - получить с сервера какой то ресурс по его URL
Можно отправить payload в тело запроса, но обычно в нем ничего не отправляют, это не принято
Туда можно запихнуть всякую дичь, но сервер будет игнорировать и наверное даже ничего не сломается
curl --request GET https://it-website.ru
curl -X GET https://it-website.ru

Query string в URL (Uniform Resource Locator) представляет собой часть URL, которая используется для передачи параметров или данных на сервер. Он начинается с символа вопроса ? и содержит пары ключ-значение, разделенные символом &.
Вот пример URL с query string:
https://example.com/search?q=term&page=2
Здесь:
    https://example.com/search - это базовый URL.
    ?q=term&page=2 - это query string, где q и page - ключи, а term и 2 - их соответствующие значения.
Таким образом все параметры запроса при использовании метода GET передаются в URL

https://example.com/search?q=term&page=2

POST - создать сущность\новый ресурс (запостить) на сервере. Не идемпотентен. Сервер отвечает статусом 201 (Created) + инфа о созданном ресурсе (ID и URL)
PUT - редактировать всю сущность (редактирует все поля). Полное обновление ресурса. Вся инфа о ресурсе должна быть отправлена в запросе, даже если изменилась только часть данных. Это идемпотентный метод, то есть многократные запросы PUT приведут к одному результату, который появится после первого запроса. Используется для полного обновления ресурса на сервере. Если ресурс не существует, PUT может создать его.
PATCH - редактировать\обновить часть сущности (не все поля). Клиент отправляет только те данные, которые надо изменить.
DELETE - удалить ресурс

OPTIONS - обычно отсылается не нами, а самим браузером. Получение от сервера списка поддерживаемых HTTP методов, обычно не содержит тела запроса. Идемпотентен. Это как пинг, мы забрасываем удочку серваку и сспрашиваем живой ли он и готов ли принимать HTTP запросы и какие методы ты поддерживаешь

TRACE - позволяет клиенту видеть что происходит с его запросом по пути к серверу. Позволяет отправить спец запрос на сервер, который в ответ возвращает содержимое твоего запроса и все прокси через которые прошел запрос. Это нужно если между клиентом и сервером есть прокси-сервера и они могут менять запрос. В ответе отобразятся через какие прокси идет запрос и как твой запрос видит конечный сервер.
CONNECT - позволяет установить прямое TCP соединение с сервером, находящимся за прокси. Чаще всего этот меод используется если между клиентом и сервером http прокси, а надо установить https соединение.
HEAD - типо GET, но мы получем ресурс без тела, только метаданные (тип содержимого, размер, дата).
методы применения: проверить доступен ли ресурс на сервере, узнать только метаданные и соответственно инфу о кешировании

Все методы можно посмотерть тут https://www.iana.org/assignments/http-methods/http-methods.xhtml

    HTTP body
В теле запроса отправляются данные

    HTTP status 

1** - информационные  (устаревшие)
    100 - Continue - Он используется для указания клиенту, что начальная часть его запроса была успешно получена сервером, и клиент может продолжить отправку оставшейся части запроса (например, тела запроса). Например если POST слишком большой по размеру.
    101 - Switching Protocols - Клиент запрашивает изменение протокола соединения, например, с HTTP на WebSocket, и сервер подтверждает это изменение.

2** - success
    200 - OK
    201 - Created
    204 - No Content - Клиент отправляет запрос на удаление ресурса, и сервер подтверждает успешное удаление, не возвращая содержимого.

3** - redirect
    301 - redirect temporarily
    302 - redirect permanently
    304 - Not Modified - Клиент запрашивает ресурс с использованием кэшированного содержимого, и сервер сообщает, что содержимое не изменилось, что позволяет использовать кэшированные данные.

4** - client error
    400 - bad request - не валидное мыло, не заполненное поле, не подходит по длине пароль. В основном ошибки валидации. Так же невалидное значение в теле запроса (синтаксис джейсона неверный). Клиент отправляет запрос с неправильным синтаксисом или недопустимыми данными, и сервер не может его обработать
    401 - unauthorized - пользователь пытается зайти на ресурс, где он не залогинился. Например когда истек срок действия токена
    402 - payment required - например для доступа к ресурсу требуется подписка, котрой у нас нет
    403 - forbidden - мы залогинены, но нет прав для доступа к данному ресурсу (в админке у маркетолога нет доступа к редактированию списка пользователей). По хорошему кнопка "Редактировать" вообще не должна существовать на фронтенде маркетолога
    404 - not found - неправильно ввели URL
    409 - conflict - когда создаем пользователя и база данных смотрит и он есть (по мылу или имени), то сервер отвечает нам - конфликт. Другими словами создание ресурса с идентификатором, который уже существует
    418 - I'm a teapot - Этот код был введён как шутка в апрельских RFC и используется в контексте серверов чая.
    429 - Too Many Requests - Клиент отправляет слишком много запросов за короткий период времени, и сервер ограничивает частоту запросов.

5** - ошибки сервера
    500 - внутренняя ошибка сервера (например БД не отвечает)
    503 - сервис недоступен (например из-за перегрузки или ТО)
    502 - Bad Gateway - Этот код указывает, что сервер, работающий как шлюз или прокси, получил недействительный ответ от вышестоящего сервера.
    504 - Gateway Timeout - Этот код указывает, что сервер, работающий как шлюз или прокси, не получил своевременный ответ от вышестоящего сервера.

                        Структура HTTP-запроса

HTTP-запрос состоит из трех основных частей: стартовая строка, заголовки и тело запроса (опционально).

1. Стартовая строка (Request Line)
Стартовая строка включает метод запроса, целевой URI и версию протокола HTTP.
GET     /index.html     HTTP/1.1

2. Заголовки запроса (Request Headers)
Заголовки содержат информацию о клиенте, сервере и характере запроса. Каждая строка заголовка состоит из имени заголовка и значения, разделённых двоеточием.
Host: example.com - обязательный заголовок, остальных может не быть 
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: keep-alive

3. Тело запроса (Request Body)
Тело запроса используется для передачи данных в POST, PUT и других методах, где данные отправляются на сервер.

Пример (для метода POST):
POST /login HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 32

username=johndoe&password=secret

                        Структура HTTP-ответа

HTTP-ответ также состоит из трех основных частей: статусная строка, заголовки и тело ответа.

1. Статусная строка (Status Line)
Статусная строка включает версию протокола HTTP, статус код и текстовое сообщение статуса.
HTTP/1.1 200 OK

2. Заголовки ответа (Response Headers)
Заголовки содержат информацию о сервере и возвращаемых данных. Каждая строка заголовка состоит из имени заголовка и значения, разделённых двоеточием.
Date: Mon, 27 Jul 2021 12:28:53 GMT
Server: Apache/2.4.1 (Unix)
Last-Modified: Wed, 22 Jul 2021 19:15:56 GMT
Content-Length: 88
Content-Type: text/html
Connection: Closed

3. Тело ответа (Response Body)
Тело ответа содержит данные, которые сервер возвращает клиенту. Это может быть HTML-страница, JSON-данные, изображение и т.д.

<html>
<head>
  <title>Sample Page</title>
</head>
<body>
  <p>This is a sample page.</p>
</body>
</html>

    1. Заголовки запросов (Request Headers)

Host: Указывает доменное имя сервера (и порт, если не стандартный), к которому направляется запрос.
Host: example.com
Хост это обязательный заголовок и присутствует в каждом запросе. Остальных заголовков может не быть

User-Agent: Информация о клиенте (браузере или другом программном обеспечении), отправляющем запрос.
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36

Accept: Указывает типы контента, которые клиент готов принять.
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8

Accept-Language: Указывает предпочтительные языки клиента.
Accept-Language: en-US,en;q=0.5

Accept-Encoding: Указывает поддерживаемые клиентом методы сжатия данных.
Accept-Encoding: gzip, deflate, br

Authorization: Передает данные аутентификации для доступа к защищенным ресурсам.
Authorization: Basic dXNlcjpwYXNzd29yZA==

Cookie: Отправляет на сервер данные из сохраненных на клиенте куки.
Cookie: sessionId=abc123; theme=light

Referer: Указывает URL-адрес предыдущей веб-страницы, с которой был произведен переход на текущую страницу.
Referer: https://www.google.com/

Content-Type: Указывает тип контента, передаваемого в теле запроса (чаще всего используется с POST и PUT запросами).
Content-Type: application/json

Content-Length: Указывает длину тела запроса в байтах.
Content-Length: 348

    2. Заголовки ответа (Response Headers)

Content-Type: Указывает тип контента, возвращаемого сервером.
Content-Type: text/html; charset=UTF-8

Content-Length: Указывает длину тела ответа в байтах.
Content-Length: 1024

Set-Cookie: Используется сервером для отправки кук на клиент. Чтобы клиент сохранил их у себя.
Set-Cookie: sessionId=abc123; Path=/; HttpOnly

Location: Указывает URL для перенаправления клиента (чаще всего используется с кодами 3xx).
Location: https://www.example.com/newpage

Cache-Control: Управляет кешированием как на стороне клиента, так и на стороне прокси-сервера.
Cache-Control: no-cache, no-store, must-revalidate

Last-Modified: Указывает время последней модификации возвращаемого ресурса.
Last-Modified: Wed, 21 Oct 2021 07:28:00 GMT

ETag: Уникальный идентификатор версии ресурса, используемый для контроля версий и оптимизации кеширования.
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"

Server: Информация о сервере, обработавшем запрос.
Server: Apache/2.4.1 (Unix)

WWW-Authenticate: Указывает метод аутентификации, используемый для доступа к защищенному ресурсу (чаще всего используется с кодом 401 Unauthorized).
WWW-Authenticate: Basic realm="Access to the staging site"

Allow: Указывает методы HTTP, поддерживаемые сервером для данного ресурса (чаще всего используется с кодом 405 Method Not Allowed).
Allow: GET, POST, HEAD

    3. Общие заголовки (General Headers)

Эти заголовки могут использоваться как в запросах, так и в ответах.

Connection: Управляет параметрами текущего соединения. Чтобы не закрывать TCP сессию после каждого запроса.
Connection: keep-alive

Date: Указывает дату и время отправки сообщения.
Date: Tue, 15 Nov 2021 08:12:31 GMT

Transfer-Encoding: Указывает форму кодирования, используемую для передачи тела сообщения.
Transfer-Encoding: chunked

                            Хранилища данных

В рамках клиент-серверной архитектуры нужная для работы информация загружается с сервера и хранится на клиенте. Основные места хранения информации:
- Кэш
- Web storage: Local storage и Session storage
- Cookies

                                                КЭШ

Кеш на бэкенде и в браузере (на клиенте)

    Кеш на бэкенде
Кеш - промежуточное хранилище данных с быстрым доступом, содержащее инфу,которая может быть запрошена с наибольшей верояностью
Cache service - сторонний кеш (Radis)
In-memory cache - кэш, который хранится в RAM на самом серваке
При запросе сервер сначала проверяет свой in-memory cache, далее в cache service, далее в БД, получает инфу из БД, сохраняет во всех кешах и отдает клиенту
Cache invalidation - обновление кеша, если появилась новая инфа

    Кеш в браузере
Как долго хранить кеш решает сервер
Cache-control, expires - хэдеры

            HTTP-заголовки кеширования (caching headers) используются для управления поведением кеширования как на стороне клиента (браузера), так и на стороне промежуточных прокси-серверов. Они помогают определить, как долго и где можно хранить копии ресурсов, чтобы снизить нагрузку на сервер и улучшить производительность веб-сайтов за счет уменьшения времени загрузки страниц.
Основные заголовки кеширования

    Cache-Control
        Описание: Основной заголовок для управления кешированием.
        Примеры значений:
            no-cache: Указывает, что кешированные копии не могут использоваться без повторной проверки на сервере.
            no-store: Запрещает кеширование ресурса.
            max-age=<seconds>: Указывает максимальное время (в секундах), в течение которого ресурс считается свежим.
            public: Указывает, что ресурс может кешироваться любыми кешами (клиентскими и промежуточными).
            private: Указывает, что ресурс должен кешироваться только клиентом, но не промежуточными прокси.
            must-revalidate: Требует повторной проверки ресурса на сервере после истечения его срока годности.
        Пример:
    Cache-Control: no-cache, no-store, must-revalidate
    Cache-Control: max-age=3600, public

Expires
    Описание: Указывает дату и время, после которых ресурс считается устаревшим.
    Пример:
    Expires: Wed, 21 Oct 2023 07:28:00 GMT

ETag (Entity Tag)
Описание: Уникальный идентификатор версии ресурса. Используется для проверки, изменился ли ресурс.
    Пример:
    ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"

Last-Modified
Описание: Указывает дату и время последней модификации ресурса.
    Пример:
    Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT

    
    Как работают заголовки кеширования

Заголовки кеширования позволяют серверу и клиенту обмениваться информацией о том, как и когда нужно обновлять кешированные копии ресурсов. Вот как они взаимодействуют:

Cache-Control: Наиболее гибкий и часто используемый заголовок. Например, Cache-Control: max-age=3600 указывает, что ресурс можно кешировать в течение 3600 секунд (1 часа). Клиент и промежуточные кеши будут использовать эту информацию, чтобы определить, когда нужно запросить свежую копию ресурса.

Expires: Указывает конкретную дату и время истечения срока действия ресурса. Например, Expires: Wed, 21 Oct 2023 07:28:00 GMT означает, что ресурс станет устаревшим после указанного времени. Этот заголовок может использоваться как альтернатива Cache-Control: max-age.

ETag и Last-Modified: Используются для проверки состояния ресурса. Например, клиент может отправить запрос с заголовком If-None-Match с текущим ETag или If-Modified-Since с последней датой модификации. Если ресурс не изменился, сервер ответит кодом 304 Not Modified, и клиент продолжит использовать кешированную копию.

304 - Not Modified - Клиент запрашивает ресурс с использованием кэшированного содержимого, и сервер сообщает, что содержимое не изменилось, что позволяет использовать кэшированные данные.

F5 - просто обновить страницу (если еть кеш, то инфа буднт взята оттуда)
CTRL + F5 - очистить кеш браузера  перегрузить страницу
CTRL + SHIFT + DEL - почитить кеш, куки, историю, активные сеансы



                            КУКИ
Пример с парком аттракционов и браслетом.

Куки (cookies) — это небольшие файлы, которые веб-сайты сохраняют на вашем устройстве. Они используются для различных целей, включая:

    Аутентификация: Помогают распознавать пользователей после авторизации, чтобы не приходилось вводить логин и пароль каждый раз при посещении сайта.
    Персонализация: Сохраняют настройки и предпочтения пользователя, например, язык интерфейса или тему оформления.
    Отслеживание активности: Собирают информацию о поведении пользователя на сайте для анализа и улучшения пользовательского опыта.
    Таргетированная реклама: Позволяют показывать рекламу, которая может быть интересна пользователю, на основе его предыдущих действий и интересов.

Куки могут быть временными (сессионными), которые удаляются после закрытия браузера, или постоянными, которые остаются на устройстве до их удаления пользователем или истечения срока действия.

Механизм использования куки для аутентификации включает несколько шагов:

    Вход пользователя: Когда пользователь вводит свои логин и пароль на веб-сайте и нажимает кнопку "Войти", сервер проверяет эти данные на соответствие учетной записи в базе данных.
    Создание сессии: Если данные аутентификации верны, сервер создает уникальную сессионную идентификацию (session ID). Эта идентификация представляет собой уникальный идентификатор текущей сессии пользователя.
    Создание куки: Сервер создает куки, содержащий session ID, и отправляет его обратно в браузер пользователя вместе с ответом на запрос.
    Сохранение куки в браузере: Браузер сохраняет этот куки на устройстве пользователя. Куки может быть сессионным (удаляется после закрытия браузера) или постоянным (сохраняется на определенное время).
    Использование куки для аутентификации: При каждом последующем запросе к серверу (например, при переходе на другую страницу), браузер отправляет куки вместе с запросом. Сервер проверяет session ID в куки, чтобы определить, что запрос исходит от аутентифицированного пользователя.
    Проверка и обновление сессии: Сервер проверяет, действителен ли session ID, и если да, то позволяет пользователю получать доступ к защищенным ресурсам. В некоторых случаях сервер может обновлять session ID для обеспечения безопасности.
    Завершение сессии: Когда пользователь выходит из системы (например, нажимает кнопку "Выйти"), сервер удаляет или инвалидирует session ID, и соответствующий куки либо удаляется, либо становится недействительным. Браузер также может удалить этот куки.

Этот механизм обеспечивает безопасную идентификацию и аутентификацию пользователя на протяжении всей сессии, позволяя пользователю получать доступ к защищенным ресурсам без повторного ввода логина и пароля.

Для собеседования достаточно запомнить, что размер куки 4кб (точнее 4096 bytes) на один куки, а остальные хранилища более 5мб. 

Флаги - не что иное, как атрибуты cookies, предназначенные для различных целей, или просто названия значений, которые могут быть использованы для идентификации этих чисел.

Виды флагов:
- Secure: Может быть установлен либо в true, либо в false. Если установлено значение true, cookie будет отправляться только при соединении HTTPS. Это может быть использовано для снижения риска атаки MITM, при которой злоумышленник заставляет пользователя просматривать сайт по протоколу HTTP. Если этот флаг установлен, cookie не будет передаваться по HTTP.
- HttpOnly: Если установлено значение true, JavaScript на стороне клиента не сможет получить доступ к файлу cookie. Это может быть использовано для сохранения cookie от XSS-атаки, которая крадет cookie. Таким образом, javascript на стороне клиента не сможет получить доступ к cookie.





                        REST API

REST (Representational State Transfer) — это архитектурный стиль, который используется для разработки сетевых приложений. Он определяет набор ограничений и принципов для создания веб-сервисов, которые могут взаимодействовать друг с другом через стандартные HTTP-протоколы.

RESTful — это описание веб-сервисов, которые реализуют принципы REST. Когда говорят, что API является RESTful, это означает, что оно следует правилам и принципам REST.

                        JSON

JSON — это JavaScript Object Notation, самый популярный формат обмена данными между приложениями. Этот формат очень похож на объекты JavaScript.

JSON-Объект заключён в фигурные скобки {} в начале объекта и в конце, состоит из формата ключ-значение, разделённого двоеточием, каждая из пар отделяется запятой.

{
  "brand": "Apple",
  "model": "iPhone 15 Pro Max",
  "isAvailable": true,
  "display": 6.69,
  "memories": [256, 512, 1024],
  "features": {
    "tripleCamera": true,
    "faceId": true,
    "touchId": false,
    "eSIM": true
  }
}

Ключ всегда имеет строковый тип данных — заключён в кавычки "brand".
Значение может быть одним из следующих типов данных:
- string (строка, например: "brand" или "123" — может сбить с толку, но т.к. число в кавычках, то тип данных именно строковый)
- number (число, например: 123)
- object (объект, например: { "brand": “Apple” } ) , обьект внутри обьекта называется nested Object
- array (массив, например: [ "apple", "orange", "kiwi" ]
- boolean (Булево значение, Логический тип данных, т.е. одно из 2х значение истина и ложь: либо true, либо false)
- null (нул, отсутствие какого-либо объектного значения, не путать с нулём: 0 — это конкретное значение, тип данных которого число)

                        Swagger

Swagger — это широко используемый фреймворк для описания, проектирования, создания, документирования и потребления RESTful веб-сервисов. Он предоставляет набор инструментов и спецификаций, которые помогают разработчикам работать с API. Swagger позволяет стандартизировать документацию API, что облегчает работу с ними как разработчикам, так и пользователям.

В сваггере описаны методы, которые используются на бэкенде, обязательные и необязательные поля, типы данных, а также ожидаемые ответы и статус коды успешных и неуспешных вызовов.

Из Swagger можно экспортировать коллекцию запросов в Postman через Import swagger.json
Достаточно скопировать адрес этого .json файла
Swagger коллекция — это просто большой JSON файл

                        Postman

Основное назначение Postman - облегчить разработку, тестирование и документирование API. С его помощью можно отправить данные в запросе и проверить полученный ответ. Также у него есть много других интересных возможностей. Можно например сохранять запросы в папки и коллекции, удобно параметризовывать запросы. Запускать коллекции с помощью Collection Runner и использовать их как автоматизированные тесты. Postman позволяет проектировать дизайн API и создавать на его основе Mock-сервер.

Тестировщики, с помощью Postman могут отправлять HTTP/HTTPS запросы к сервисам и получать ответы от них. С помощью такого подхода можно протестировать бэкенд сервисы и убедиться, что они работают корректно. С помощью Postman можно выполнять запросы к различным типам API, таким как REST, SOAP и GraphQL.

Endpoint - это URL, который предоставляет доступ к определенной функциональности сервиса. Каждый эндпоинт связан с определенным http методом (GET, POST и тд), который и определяет тип операции, которую можно выполнить с помощью этого эндпоинта.


Параметры могут использоваться для передачи данных, которые необходимы для выполнения операции, определенной методом HTTP, и могут варьироваться в зависимости от используемого метода. Например параметры могут использоваться для передачи настроек фильтрации, сортировки или поиска, чтобы получить только нужные данные

PATH параметры указываются прямо в URL
https://petstore.swagger.io/v2/pet/:id - в окошке постмана появится поле для ввода id

Query параметры, натболее часто используются с GET, но могут и с любым другим. Порядок параметров не играет роли.
От основной части URL эти параметры отделяются "?", а друг от друга "&"/.
Каждый такой параметр представлен парой из имени и значения, а между ними "="
Некоторые символы могут быть закодированы, чтобы избежать ошибок при передаче спец символов
http://petstore.swagger.io/v2/pet/findByStatus?status=sold&price=1000

https://learning.postman.com/docs/tests-and-scripts/write-scripts/variables-list/ - рандомные динамические переменные

CTRL + ALT + C - открыть консоль в постман

pm.collectionVariables.set("param", JSON.parse(responseBody).args.name)

    Переменные в JavaScript

let text; - обьявляем переменную без присваивания значения
text = "hello"; - присваиваем значение
console.log(text); - выводим переменную в консоль 

Можно сократить запись 
let text = "hello";
console.log(text);

Можно присвоить число
let petId = 1;
console.log(petId);

Важно учитывать область видимости переменной. Если взять переменную в блок кода (он окружен кавычками), то после кавычек он не будет работать.
В данном примере скрипт выведет - hello и затем ошибку что переменная text не определена
{
    let text = "hello";
    console.log(text);
}
console.log(text);

А вот тут сработает нормально. Сначала - hello , затем - bye
let text = "bye";
{
    let text = "hello";
    console.log(text);
}
console.log(text);

Еще пример
let side1 = 3;
let side2 = 4;
let side3 = 5;
console.log(side1 + side2 + side3);

    функции в JavaScript

function triangleSum() {
    let side1 = 3;
    let side2 = 4;
    let side3 = 5;
    console.log(side1 + side2 + side3);
}

triangleSum() - НЕ ЗАБЫТЬ ВЫЗВАТЬ ФУНКЦИЮ, так как просто определение функции не вызывает ее

Можно добавить параметры в тело функции, чтобы можно было изменять ее при вызове
function triangleSum(side1, side2, side3) {
    console.log(side1 + side2 + side3);
}

triangleSum(1, 5, 2)
triangleSum(3, 1, 1)

8
5

Еще
function triangleSum(side1, side2, side3) {
    return side1 + side2 + side3;
}

let sum = triangleSum(3, 4, 5);
console.log(sum);

sum = triangleSum(5, 6, 7);
console.log(sum);

    Сложение строк в JavaScript

let petId = 350;
let petName = "Bobik";
let petStatus = "available";

console.log("Pet info: id = " + petId + ", name = " + petName + ", status = " + petStatus);

Pet info: id = 350, name = Bobik, status = available - вывод в консоли

 Обьекты в JS

let pet = {
    id: 350,
    name: "Bobik",
    status: "available"
};

console.log("Pet info: id = " + pet.id + ", name = " + pet.name + ", status = " + pet.status);

Pet info: id = 350, name = Bobik, status = available - вывод в консоли

    Методы в JS (функции внутри обьекта называются методы обьекта)

let pet = {
    id: 350,
    name: "Bobik",
    status: "available",

    info: function() {
        console.log("Pet info: id = " + pet.id + ", name = " + pet.name + ", status = " + pet.status);
    }
}

pet.info();

Pet info: id = 350, name = Bobik, status = available - вывод в консоли

То же самое, но чтоб не ошибится можно использоват - this, это слово позволяет сослаться на текущий обьект, внутри которого оно используется

let pet = {
    id: 350,
    name: "Bobik",
    status: "available",

    info: function() {
        console.log("Pet info: id = " + this.id + ", name = " + this.name + ", status = " + this.status);
    }
}

pet.info();

Код post-res для вывода в консоль значения ключа, пришедшего в теле ответа. В данном случае мы выводим значение ключа id
let printInfo = function() {
    let id = pm.response.json().id;
    console.log(id);
};

printInfo();
