FIRMWARE STAGE
1. Подача питания на комп (кновка включения)
2. Включается прошивка (firmware) BIOS (basic input/output system) или UEFI (Unified Extensible Firmware Interface) Это микросхема, расположенная на материнской плате. ПОсле включения процессор читает код BIOS из микросхемы ПЗУ (ROM), записывает его в RAM и происходит его выполнение.
3. POST (power-on self test). Инициализируется оборудование (что есть вообще), тестируется конфигурация оборудования, чтобы понять что аппаратное обеспечение работает правильно. 
NOTE! CMOS (Complementary Metal-Oxide-Semiconductor)- это оперативная память небольшого объема (обычно 256 байт), входит в сотав южного моста, питается от небольшой  батарейки, расположенной на материнской плате. В этой памяти сохраняются различные настройки и сведения о конфигурации, которые использует в своей работе BIOS.
Пользователь может получить доступ к некоторым из них, зайдя в режим "настроек BIOS" или BIOS Setup. Для этого нужно после включения ноутбука нажать на клавиатуре определенную клавишу
Таким образом BIOS хранится в энергонезависимой памяти и служит для запуска коипьютера. Одним из режимов его работы является режим настроек. Эти настройки, а так же другие, недоступные пользователю, хранятся в памяти CMOS, которая запитана от батарейки. От этой же батарейки идут часы.
Если POST прошел успешно, то:
4. BIOS, согласно настройкам анализирует какие есть утройства хранения информации и на каком соответственно искать MBR (Master Boot Record) или GPT (GUID Partition Table, есть в начале и в конце для надежности). Находится на первом секторе диска и равна 512 байтам (состоит из загрузчика - first stage bootloader (код загрузки или bootstrap code) размером 446 байт и таблицы разделов размером 64 байт (по 16 байт на раздел, таким образом при использовании MBR можно сделать только 4 основных(primary, активных) раздела, на которых можно разместить ОС) и 2 байта для цифровой подписи. Последние два байта MBR называются сигнатурой. Значение этих 2х байтов должно быть 55h AAh. В случае, если это не так, запись считается некорректной. ).
5. Далее MBR смотрит какие есть разделы на данном диске и какой раздел помечен как активный, чтобы считать его по умолчанию. Передает эстафету загрузчику этого активного раздела (PBR, partition boot record), который например хранится по адресу boot/grub, и уже этот загрузчик считывает свой конфиг файл grub.cfg и берет оттуда данные что и куда грузить (ядро, корень, опции и инитрд)
NOTE! Если загрузчик может полностью уместиться в первые 512 байт основной загрузочной записи и запустить операционную систему с этим ограниченным объемом кода, он считается одноступенчатым загрузчиком

Если заменить BIOS на UEFI, то отпадает необходимость в загрузчике в MBR. При включении UEFI ищет раздел EFI System Partition и загружает оттуда bootx64.efi или grubx64.efi, а это запускает GRUB.

BOOTLOADER STAGE

SECOND BOOTLOADER
6. Теперь считывается Second stage bootloader из PBR активного раздела. Представляет собой исполняемые файлы и конфигурац файлы.
Загрузчики LInux:
- GRUB (GRAND Unified Bootloader)
- GRUB 2
- Lilo (Linux Loader)
- Bootx
- Sparc Improved bootLOader (SILO)
- Yet Another BOOTloader (YABOOT)
- Также возможна загрузка из сети через Preboot Execution Environment (PXE). В системе PXE совместимая материнская плата и сетевая карта обладают достаточным интеллектом, чтобы получить адрес из сети и использовать протокол TFTP (Trivial File Transfer Protocol) для загрузки специального загрузчика с сервера.

Загрузчик знает где лежит ядро, знает его параметры загрузки (можно настроить), грузит ядро в RAM, грузит Initial Ram disk (initrd - содержит конфиг файлы и модули для загрузки ядра)
Можно загрузить ядро в режиме обслуживания

GRUB

GRUB Legacy может иметь один или оба из следующих двух основных конфигурационных файлов: файлы /boot/grub/menu.lst и /boot/grub/grub.conf В зависимости от дистрибутива один файл предпочтительнее другого. В качестве примера можно привести дистрибутивы Red Hat, ориентированные на файл grub.conf, и дистрибутивы SUSE, предпочитающие использовать файл menu.lst Во многих дистрибутивах один из этих файлов просто существует как символическая ссылка на другой.

Not only does GRUB Legacy not distinguish between SATA and IDE drives, it also doesn't number drives with letters like the operating system does. For example, the first hard drive is 0, not a.
Additionally, the partition numbers are different. The operating system numbers the first partition of a drive 1, while for GRUB Legacy it would be partition 0.
For example, the device /dev/sda1 might be referred to as hd0,0 in GRUB Legacy. The device /dev/hdb3 might be hd1,2 in GRUB Legacy. The term "might be" is used because the drive number really depends on the order in which GRUB Legacy "finds" the drives.

Grub legasy именует все с 0, например sda1 будет hd(0,0), а Grub2 - диск именуте с 0, а партицию с 1, напрмер sda1 будет hd(0,1)

/boot/grub/grub.cfg - содержит настройки, но его изменять нельзя (в RedHat /boot/grub2/grub.cfg)
/etc/default/grub - можно изменять
update-grub - обновить инфу после смены настройке (для Debian)
grub2-mkconfig - обновить инфу после смены для RedHat


grub-mkconfig - команда чтобы создать конфиг граба
Команда grub-mkconfig запросит у работающей системы содержимое каталога /boot, содержимое каталога /etc/default/grub, если оно существует, и все скрипты, расположенные в каталоге /etc/grub.d /etc/default/grub
Затем он выведет правильно отформатированный конфигурационный файл в указанное место:
grub2-mkconfig -o /boot/grub2/grub.cfg - сделает новый конфиг (для RedHat) (-o указывает место вывода)

grub-md5-crypt - для задания пароля на grub

/sbin/grub2-install /dev/sda - установить grub2
после установки надо сгенерировать конфиг 


Директивы GRUB LEGASY для /boot/grub/grub.conf
 grub.conf содержит по крайней мере три директивы: root, kernel и initrd. Эти title надписи определяют загружаемую операционную систему, а также параметры ядра, указывающие, как загрузить операционную систему и initrd.

#global options
default=0
fallback=1
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
password notencypted

#bootable title sections
title CentOS (2.6.32-358.6.1.el6.i686)
	root (hd0,2)
	kernel /vmlinuz-2.6.32-358.6.1.el6.i686 ro root=/dev/mapper/vg_livecd-lv_root rd_NO_LUKS LANG=en_US.UTF-8 rd_LVM_LV=vg_livecd/lv_swap rd_NO_MD rd_LVM_LV=vg_livecd/lv_root SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
	initrd /initramfs-2.6.32-358.6.1.el6.i686.img
title CentOS (2.6.32-358.2.1.el6.i686)
	password --md5 $1$D20Ia1$iN6djlheGF0NQoyerYgpp/
	root (hd0,2)
	kernel /vmlinuz-2.6.32-358.2.1.el6.i686 ro root=/dev/mapper/vg_livecd-lv_root rd_NO_LUKS LANG=en_US.UTF-8 rd_LVM_LV=vg_livecd/lv_swap rd_NO_MD rd_LVM_LV=vg_livecd/lv_root SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
	initrd /initramfs-2.6.32-358.2.1.el6.i686.img
title OtherOS (Windows)
	rootnoverify (hd0,0)
	chainloader +1

Директива 	Значение
default= 	Указывает заголовок, который будет пытаться загрузиться по умолчанию по истечении времени ожидания в секундах.
fallback= 	Указывает заголовок, который будет пытаться загрузиться, если заголовок по умолчанию не может загрузиться успешно.
timeout= 	Указывает количество секунд ожидания перед автоматической попыткой загрузки заголовка по умолчанию.
splashimage= 	Укажите фоновый рисунок, который отображается за текстом меню.
hiddenmenu 	Запрещает GRUB Legacy отображать все, кроме загрузочного заголовка по умолчанию, до тех пор, пока пользователь не нажмет клавишу. Если пользователь нажимает клавишу, то отображаются все титры.
title 	Директива title запускает новый блок директив, которые формируют директивы, необходимые для загрузки системы. Основная надпись заканчивается, когда появляется следующая директива title или когда достигается конец файла.
root 	Использует специальный синтаксис жесткого диска для ссылки на расположение каталога /boot.
kernel 	В этой строке указывается файл образа ядра, за которым следуют все параметры, передаваемые ядру, такие как ro только для чтения и rootroot=/path/to/rootfs.
initrd 	В этой строке должен быть указан начальный ramdisk, соответствующий версии и выпуску ядра Linux. Этот файл предоставляет минимальную файловую систему во время инициализации ядра перед монтированием корневой файловой системы.
password 	Этот параметр может быть использован либо как глобальный параметр, либо как параметр заголовка. При глобальном задании пользователь должен ввести указанный пароль перед добавлением, редактированием или использованием командной строки GRUB Legacy. В качестве опции заголовка требуется, чтобы пользователь ввел пароль, прежде чем GRUB попытается загрузить заголовок.
rootnoverify 	Эта директива используется для указания загрузочного раздела для операционной системы, отличной от Linux.
chainloader 	Используется для указания пути к другому загрузчику или +1, если загрузчик находится в первом секторе раздела, указанном директивой rootnoverify.

Это etc/default/grub: (для GRUB2)

GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"
GRUB_DEFAULT=saved
GRUB_SAVEDEFAULT=true
# GRUB_TERMINAL="serial console"
# GRUB_SERIAL_COMMAND="serial --unit=0 --speed=9600"
GRUB_CMDLINE_LINUX="quiet rhgb"  # сюда можно прописать постоянные параметры загрузки
GRUB_DISABLE_RECOVERY="true"

Чтобы сделать второй пункт меню пунктом меню по умолчанию, администратор должен выполнить:
    grub-set-default 1

Если GRUB 2 необходимо установить или переустановить, то администратор выполнит:
    /sbin/grub2-install /dev/sda
После установки GRUB 2 необходимо сгенерировать конфигурационный файл в первый раз. В дистрибутиве, основанном на Fedora, администратор должен выполнить:
    grub2-mkconfig -o /boot/grub2/grub.cfg
В дистрибутиве на основе Ubuntu администратор выполнит:
    update-grub

cat /proc/cmdline - посмотреть опции загрузки ядра

KERNEL STAGE
7. Ядро (kernel)
Находится в папке /boot/vmlinuz-x.y.z.-a 
Слово - generic значит общий образ, без лишних модулей.
В этой папке может хранится много ядер
Вообще ядро представлено остовом - vmlinuz (без драйверов, то есть без возможности использования оборудования) и несколькими модулями. Но вместо этих модулей вместе с ядром загружается RAM-диск (архив с некоторым количеством этих модулей) - initramd или initramfs.
Ядро должно инициализировать все аппаратные драйверы и смонтировать корневую / файловую систему для следующего и запутить первый процесс - init.
Однако возможно, что корневая файловая система существует на устройстве, которое ядро не знает, как поддерживать. Как минимум ядру нужны наприпер модули scsi и ext4. Но где их взять? Решением этой проблемы является initrd RAM-диска. Драйверы ядра, необходимые для продолжения загрузки, встроены в псевдо-файловую систему, которая хранится рядом с самим ядром в /boot в файле initrd.img. Ядро загружается, монтирует initrd, таким образом монтируется псевдо-файловая система (мини корневая файловая система, на которой ей все то же что и на обычной), которая загружает драйверы внутрь, а затем уже можно смонтировать реальную корневую файловую систему, используя новые драйверы. Это позволяет легко добавлять драйверы в ядро, а ядро монтировать корневую файловую систему практически на любом оборудовании для хранения данных, даже если оно подключено к сети.
ядро способно смонтировать в самом себе необходимую корневую файловую систему, однако для этого подобному ядру придётся удерживать все обсуждавшиеся исполняемые файлы, библиотеки поддержки, файлы настройки и т.п. в своём файле vmlinuz. Это создаст большое число проблем.

Это испортит основной повод исполняемого самого файла ядра.
Исполняемый файл такого ядра будет гигантским в размере. Чем большим размером будет обладать исполняемый файл, тем сложнее его сопровождение.
Такой громадный исполняемый файл сложный в поддержке, обновлении, совместном использовании и обработке в серверах (с точки зрения пакетов RPM).
Этот подход не будет следовать правилу KISS (keep it simple, stupid - делай проще, тупица).
                
							INIT STAGE
Существует несколько стилей процусса init
- SystemV или SysV или SysVinit(родительский процесс инициализации системы на одном из заданных уровне запуска (runlevel) Их всего 6шт)
- UpStart (на основе отслеживания событий. Если что то не запустилось или упало, то повторно)
- Systemd (в ускоренном режиме, засчет параллельного запуска)
Даже если ваша система использует Systemd или Upstart в качестве замены традиционного процесса init, обе замены используют исполняемый файл с именем init по пути /sbin/init --> /lib/systemd/systemd
В системах systemd файл /sbin/init является символической ссылкой на файл /lib/systemd/systemd в целях совместимости.
                 
                 INIT (System V)
Если используется традиционная система init(SystemV), то файл /etc/inittab используется для определения того, какие скрипты будут запускаться для запуска служб системы

Файл inittab указывает на другие скрипты, которые выполняют эту работу, обычно хранящиеся в каталоге 
/etc/init.d (тут хранятся все скрипты)

id:3:initdefault: - данная строка в файле inittab указывает runlevel по умолчанию. Его можно изменить прямо тут.

/etc/ rc0.d -> rc.d/rc0.d
      rc1.d -> rc.d/rc1.d    и т.д.
      Здесь хранятся скрипты для каждого runlevelа в виде некоторых ссылок на скрипты в папке /etc/init.d (где хранятся все скрипты)
например: K15httpd -> ../init.d/httpd
          S55sshd -> ../init.d/sshd
Начинается с буквы Kill или Start и цифры, указывающий поряд вкл или откл.

runlevel - посмотреть текщий уровень выполнения
who -r - тоже
init НОМЕР - сменить runlevel немедленно
telinit НОМЕР - аналогично
telinit q - restore configuration, после изменения конфига файла /etc/inittab


Сценарии, используемые init для установки каждого уровня запуска, хранятся в каталоге /etc/init.d/ Каждый уровень запуска имеет связанный каталог в /etc/, именуемый /etc/rc0.d/, /etc/rc1.d/, /etc/rc0.d/ и т.д., со сценариями, которые должны выполняться при запуске соответствующего уровня запуска. Поскольку один и тот же сценарий может использоваться разными уровнями запуска, файлы в этих каталогах являются просто символическими ссылками на реальные сценарии в /etc/init.d/ Кроме того, первая буква имени файла ссылки в каталоге уровня запуска указывает, должна ли служба быть запущена или завершена для соответствующего уровня запуска. Имя файла ссылки, начинающееся с буквы K, определяет, что служба будет уничтожена при входе на уровень запуска (kill). Начиная с буквы S, сервис будет запускаться при входе в уровень запуска (start). Например, в каталоге /etc/rc1.d/ будет много ссылок на сетевые скрипты, начинающиеся с буквы K, учитывая, что уровень запуска 1 является однопользовательским уровнем запуска без подключения к сети.

               SYSTEMD

Unit - модули, которыми оперирует системди
Они бывают:     .service
                .mount
                .device
                .socket

 /usr/lib/systemd - директория с юнитами по умолчанию
 В системах systemd файл /sbin/init является символической ссылкой на файл /usr/lib/systemd в целях совместимости.
 
В ней есть помимо всего две папки 
system - с юнитами для системы
user - с юнитами для пользователя
 /etc/systemd - директория с юнитами, которыми может управлять админ и файлами настройки (как /etc/inittab в SystemV)

Если традиционный init был заменен на Systemd, то файлы в каталоге /etc/systemd используются для запуска системы.

Systemd монтирует файловую систему согласно файлу /etc/fstab. В нем написано что и куда монтировать. Читает остальные файлы конфигурации из /etc. И полностью загружает систему, в том числе те драйвера (видеокарта напрмаер), которые были не нужны ядру на начальном этапе загрузки.
 pstree - посмотреть дерево процессов

systemctl - команда для управления systemd. Расшифровывается как System control

systemctl list-unit-files - показать вообще все юниты
systemctl list-units - показывает все запущенные юниты
systemctl --failed - юниты которые по какой то причине не запустились
systemctl list-units --type=service - показать только сервисы
systemctl list-units --type=target - какие таргеты запущены. Так можно определить runlevel. Ну или запустить команду runlevel

systemctl start СЕРВИС(ДЕМОН)
          stop
          status 
systemctl -all - посмотреть все что работает

systemctl enable ДЕМОН - автозагрузка
          disable - отключить автозагрузку

systemctl isolate desired.target - чтобы сменить ранлевел так же как и командой runlevel
systemd.unit=desire.target - изменить ранлевел при загрузке, вписав его как параметр загрузки ядра
или
systemctl set-default -f multi-user.target - -f это форсировать, те перезаписать вмето того, который есть
systemctl get-default - посмотреть установленный для загрузки runlevel

systemctl hibernate/suspend/poweroff/reboot 
systemctl suspend - put the system in low power mode, keeping current data in memory
systemctl hibernate - copy all memory data to disk, so the current state of the system can be recovered after powering it off

systemctl list-dependencies graphical.target

RUNLEVELS
0 - halt or shut off - poweroff.target
1 - single-user mode - rescue.target
2,4 - настраиваемые режимы - multi-user.target
3- normal - multi-user.target
5 - normal with graphical display - graphical.target
6 - restart - reboot.target

/usr/lib/systemd/system/default.target - место хранения default runlevel (который запускается по умолчанию). Это ссылка на target в этой же папке:
/usr/lib/systemd/system/default.target -> graphical.target


                UPSTART

Upstart was developed for the Ubuntu Linux distribution to help facilitate parallel startup of processes. Ubuntu has stopped using Upstart since 2015 when it switched from Upstart to systemd.

/etc/init -  тут хранятся все jobs (файлы с расширением .conf) На лабораторных машинах netacad эта директория есть тока на centos

/etc/init.d - тоже хранятся службы

Если традиционная инициализация была заменена на Upstart, то для завершения init системы используются сценарии в файле /etc/init.d --> rc.d/init.d , в котором находятся скрипты

Для Upstart - runlevel по умолчанию хранится в переменной DEFAULT_RUNLEVEL 
                в /etc/init/rc-sysinit.conf

initctl - аналог systemctl в systemd
initctl list - показать все сервисы, их состояние и PID

chkconfig --list НАЗВАНИЕ_ДЕМОНА - показывает что запускается, а что нет на всех уровнях
chkconfig on НАЗВАНИЕ_ДЕМОНА
chkconfig off НАЗВАНИЕ_ДЕМОНА
chkconfig --level 24 atd on - включить службу atd на уровне 2 и 4

halt, poweroff, shutdown - выключть 
shutdown now
shutdown now "СООБЩЕНИЕ ДЛЯ ВСЕХ ПОЛЬЗОВАТЕЛЕЙ"
shutdown -r - перезагрузка
shutdown +10 - выключить через 10 мини
shutdown -h - halt
shutdown -c - отменить запущенное по расписанию выключение

wall
echo -e "СООБЩЕНИЕ ВСЕМ" | wall - сообщение всем пользователям
wall file.txt
cat file.txt | wall 

etc/rc0-6.d - в этих папках расположены службы (демоны), а точнее символьные ссылки на сами демоны хранящиеся в etc/init.d/
Ссылки начинаются с буква S и цифры:
     S01ssh -> ../init.d/ssh

/etc/rc.d/init.d/httpd stop - например для систем с традиционным ИНИТ службы хранятся тут, и их можно остановить и запустить

Вместо того, чтобы вводить полный путь к сценарию, многие системы предоставляют service скрипт, который позволяет выполнять сценарий init без необходимости вводить полный путь к сценарию
service sshd start/stop/status, 
    restart - stop and then start 
    reload - read and load configuration
    configtest - check the conf files to correctness



journalctl -f - события в режиме онлайн
journalctl _UID=0 - события пользователя


acpi - чтобы экономить батарею (показывает остаток заряда, температуру)

                  GRUB

https://ru.m.wikibooks.org/wiki/Grub_2

Восстановление GRUB при испорченном grub.cfg
если /boot находится на корневом разделе, а не на отдельном диске

1) Определяем какой раздел является корневым
ls - выводит разделы 
set root=(hd0,2) - присватваем переменной root значение (hd0,2) (тот раздел,где находится /boot/ядро+initrd)
ls / - если то что отображается является корневым разделом, то все хорошо, если нет, то присваиваем переменной root другой диск.
linux /boot/vmlinuz TAB ro root=/dev/sda2 - задаем местоположение ядра в директории /boot далее параметры ro-read only и root=реальный_корневой_раздел /, а именно куда монтируется ядро
initrd /boot/initrd TAB
boot
Загружаемся
grub-install /dev/sda - устанавливаем grub на диск, а не на раздел! (можно без этой команды)
update-grub - обновляем конфигурацию (появляется grub.cfg)

2) Смотрим какие есть разделы
ls
linux (hd0,gpt2)/ TAB - если появилась возможность ввести boot и тд, то раздел тот, поэтому продолжаем команду:
linux (hd0,gpt2)/boot/vmlinuz TAB root=/dev/sda2 (указываем реальный корень диска /)
initrd (hd0,gpt2)/boot/initrd TAB
boot
Загружаемся
grub-install /dev/sda - устанавливаем grub на диск, а не на раздел! (можно без этой команды)
update-grub - обновляем конфигурацию (появляется grub.cfg)


Восстановление GRUB при испорченном первом секторе


В данном случае ничего не загружается, просто черный экран

Загружаемся с live CD
Если разделы отображаются, то переходим к монтированию, если нет, то нужно восстановить таблицу разделов внутри MBR с помощью программы
testdisk (ее надо установить)

sudo mount /dev/sda5 /mnt - монтируем корень своего нерабочего linux в папку /mnt
sudo mount /dev/sda2 /mnt/boot - монтируем /boot раздел если он находится на другом разделе
sudo grub-install --root-directory=/mnt /dev/sda - теперь переходим собственно к установке grub2. Ключ "--root-directory" позволяет указать, что использовать в качестве корневой директории. Нам нужен корневой раздел нашей системы, который примонтирован в /mnt
umount /mnt/boot 
umount /mnt
reboot

Еще вариант 
Загружаемся с live CD
sudo mount /dev/sda5 /mnt - монтируем корень своего нерабочего linux в папку /mnt
sudo mount /dev/sda3 /mnt/boot - монтируем /boot раздел если он находится на другом разделе
sudo mount --bind /dev /mnt/dev - если система обращается к папке /dev, то она будет обращаться к папке /mnt/dev
sudo mount --bind /proc /mnt/proc
sudo mount --bind /sys /mnt/sys
sudo chroot /mnt - меняем корневую директорию live CD на корневую директорию нашего не работающего linux
grub-install /dev/sda
или
grub-install --recheck /dev/sda
или
grub-install --recheck --no-floppy /dev/sda
exit - выходим с корня в live CD
Отмонтируем все по очереди 
reboot


