Установка докер в Debian:
curl -fsSL https://test.docker.com -o test-docker.sh
sudo sh test-docker.sh    

Установка докер на Ubuntu:
https://docs.docker.com/engine/install/ubuntu/#prerequisites

docker version - посм версию клиента и сервера
docker images - просмотр всех образов которые есть на локальном компе
docker rmi images имя_образа - удаление образа
docker ps - просмотр всех запущенных контейнеров
docker ps -a - просмотр вообще всех контейнеров в т.ч. не запущенных
docker rm имя_контейнера|id контейнера - удаление контейнера
docker container prune - удалить все ОСТАНОВЛЕННЫЕ контейнеры

docker run имя_образа - создать и запустить контейнер из образа
Докер сначала булет искать образ локально, а если локально его нет, то он скачает его с докер хаба
Если указать в качестве обраща hello-world, то по кмолчанию буднт скачан контейнер с ТЭГОМ :latest.
Оьраз скачивается послойно в виде архива и затем extract (при скачивании мы видим ID каждого слоя)
Запущенному контейнеру автоматически присваивается CONTAINER ID и NAME контейнера
Каждый раз при запуске команды docker run создается новый контейнер, старые остановленные не используются
docker run -it имя_образа - запуск контейнера в интерактивном режиме (-i) терминала (-t), чтобы можно было взаимодейсвовать с контейнером. Например вводить команды если запущен контейнер с линуксом

docker run -d имя_образа - запуск контейнера в виде демона (detached, фоном) иначе не возмодно будет продолжать работать в командной строке даного терминала
docker run -p 8080:80 имя_образа - проброс портов (внешний_нужный_нам:внутренний_порт_контейнера)
docker container inspect ID_контенера - инфа о контейнере
docker container inspect 3fef52c80532 | grep -i ipaddress - можно использовать grep
docker stop ID_контенера - остановить контейнер
docker kill ID_контенера - если не реагирует на команду stop
docker stop $(docker ps -q) - остановить все контейнеры
docker rm $(docker ps -a -q) - удалить все контейнеры

docker exec -it 6532ce0cea64 bash - зайти в уже запущенный контейнер и запустить там bash (запускает команду в контейнере)
docker run -p 80:80 -d -v /var/www/8080:/usr/share/nginx/html имя_образа - запустить контейнер из образа фоном, пробросить порт и примонтировать (-v создать волюм) свой каталог /var/www/8080 к контейнерному /usr/share/nginx/html
docker run -d -v ${PWD}:/usr/share/nginx/html имя_образа - можно подключить вольюм указав в качесве своей папки переменную текущей папки таким образом

docker run -d --name ИМЯ имя_образа - присвоить контейнеру свое ИМЯ, а не автоматическое
docker run --rm имя_образа - запустить контейнер из образа и после остановки контейнера удалить его автоматически

CTRL + ` - открыть терминал в VSCode
code . - открыть папку в которой нвходишься в терминале в VSCode
! + TAB - создать дефолтную html страницу (надстройка Emmet)
h1 + TAB - сразу создать открывающий и закр тэги

    Перенос строк
docker run \
-d \
-v ${PWD}:/usr/share/nginx/html \
--rm \
имя_образа

    Создание образов
1) Создать Dockerfile - спец файл с инструкциями для docker по созданию нового image
Один образ - один Dockerfile
Dockerfile — это текстовый файл, содержащий инструкции для создания Docker-образа. Он определяет, как должен быть построен образ, включая операционную систему, установку пакетов, копирование файлов, настройку окружения и запуск приложений.
2) Помещается в корень папки
3) Содержит инструкции, одна инструкция - один слой
4) Можно указат имя и тэг для образа
5) На основании готового образа можно создават контейнеры

Инструкции dockerfile:
- FROM python:alpine - указываем какой базовый образ будет испольхован для создания нашего образа
- WORKDIR /app - с помощью этой инструкции создается рабочая директория внутри образа и докер переходит внутрь этой папки
- COPY . . - копируем все папки из локальной папки компьютера в папку указанную в WORKDIR внутри контейнера
- CMD [ "python", "main.py" ] - данные команды выполняются сразу после создания контейнера уже в самом КОНТЕЙНЕРЕ, а именно процесс python выполнит файл main.py

docker build . - создать образ из докерфайла если мы находимся в папке с этим докерфайлом
docker build -f путь/имя_докерфайла - создать образ из докерфайла с нестандартным именем
docker build . -t имя_образа:2.1.3 - чтобы указать имя:тэг для образа. Если тэг опустить, то автоматически подставится тэг latest

docker run -it имя_созданного_образа - и прямо в терминале будет вывод программы написанной на питоне

    Docker Compose

Позволяет запускать несколько коньейнеров используя одну команду или допустим один контейнер, но с несколькими условиями (порты, волюмы и тд), и сотановить их
Используется .yml (YAML файл)
Большой плюс докер-компоус, это то что отдельные контейнеры могут взаимодествовать друг с другом по DNS имени, а точнее по имени сервиса
docker-compose.yaml — это файл конфигурации для Docker Compose, инструмента, который позволяет легко управлять многоконтейнерными приложениями. В этом файле описываются сервисы, сети и тома, необходимые для запуска приложения.

docker-compose up - запустить процесс создания и запуска контейнеров из файла докер-компоус.ямл
docker-compose up -d - в фоне
docker-compose down - остановить все контейнеры и удалить их
docker-compose up -d --build - если что то изменилост в файлах, то докер-компоус пересоберет образы
docker logs ID_контенера - показать логи контейнера

Пример файла docker-compose.yaml:

version: '3.8'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - .:/app
    environment:
      - FLASK_ENV=development

  db:
    image: postgres:13
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_USER=example
      - POSTGRES_PASSWORD=example
      - POSTGRES_DB=example

volumes:
  postgres_data:

Таким образом, Dockerfile описывает, как построить образ для сервиса web, а docker-compose.yaml управляет запуском web сервиса вместе с сервисом db (PostgreSQL).
Строка build: . в файле docker-compose.yaml указывает, что Docker Compose должен собрать образ для указанного сервиса из Dockerfile, который находится в текущей директории (той же папке, где находится файл docker-compose.yaml).

Если у вас несколько Dockerfile в одной директории, вы можете указать конкретный Dockerfile для каждого сервиса в docker-compose.yaml с помощью параметра context и dockerfile.

version: '3.8'

services:
  web:
    build:
      context: .
      dockerfile: Dockerfile.web
    ports:
      - "5000:5000"
    volumes:
      - ./app:/app
    environment:
      - FLASK_ENV=development

  db:
    build:
      context: .
      dockerfile: Dockerfile.db
    volumes:
      - ./db:/docker-entrypoint-initdb.d
    environment:
      - POSTGRES_USER=example
      - POSTGRES_PASSWORD=example
      - POSTGRES_DB=example

Запуск контейнеров:
Используя docker-compose, вы можете запустить оба сервиса с их специфическими Dockerfile, выполнив команду:
    docker-compose up --build
Эта команда соберет образы для обоих сервисов, используя соответствующие Dockerfile, и запустит контейнеры.

docker log id_контейнера -f - смотреть логи контейнера в комадной строке онлайн

Если зайти внутрь контейнера и что то изменить прямо в работающем контейнере, то можно сохранить эти изменения в новый образ прямо с работающего контейнера:
docker commit id_контейнера новое_название_образа:2.0

        Отправка image на dockerhub

docker tag kuber:1.0 01yura/kuber_python_server:1/0
docker images - теперь после этой команды у нас появился новый образ на основе нашего
docker login - логинимся
docker push 01yura/kuber_python_server:1.0 - пушим на сервер

docker tag 01yura/k8s-web-to-nginx-ru:latest 01yura/k8s-web-to-nginx-ru:1.0.0 - сделать из образа latest образ с какой-либо версией         
docker build . -t 01yura/k8s-web-to-nginx-ru:2.0.0 - создать образ из Dockerfile
