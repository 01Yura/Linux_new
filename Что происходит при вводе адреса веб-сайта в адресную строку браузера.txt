	Поскольку я не могу охватить все возможные сценарии, дальнейшее описание будет основано на  взаимодействии с браузером Google Chrome и OC Windows. Они, согласно всемирно известному сайту аналитики gs.statcounter.com, занимают львиную долю рынка, поэтому все примеры в статье будут в их контексте.
Так что же происходит, когда вы начинаете вводить в адресную строку своего браузера заветное xss.is?
					
                               БРАУЗЕР
Для начала, по первым введенным символам, браузер пытается понять, является ли ваш ввод URL’ом (uniform resource locator, универсальным локатором ресурса, адресом веб сайта если хотите) или поисковым запросом (что такое URL, будет описано далее). 
Поисковый запрос
Когда вы вводите первые символы поискового запроса, то браузер (в данном случае Chrome с выбранный в настройках поисковым движком от Google) отправляет запрос к Google, от которого в режиме реального времени получает наиболее популярные поисковые запросы, предлагая вам порой странные (но популярные) варианты запросов от других пользователей, такие как 
- КАК вытащить человека из тюрьмы в россии
- Я ХОЧУ новый аффончик
- КАК ЖИТЬ если ты долбаеб
(прошу прощения за пунктуационные и орфографические ошибки. Запросы были скопированы из поисковой строки браузера как есть)

URL запрос
Если браузер определил, что ваш запрос является не «поисковым», а URL’ом, то дабы улучшить ваш «пользовательский опыт», он предлагет вам варианты автозаполнения на основе вашей истории браузера и выполняет так называемый prefetching (предзагрузку)
Варианты prefetching’а:
1)	DNS prefetching (предварительный resolving доменного имени)
Chrome предугадывает, какие сайты вы, скорее всего, посетите, и заранее выполняет DNS-запросы для этих доменов.
2)	Link Prefetching (предугадывание URL)
Предугадывая сайт, на который вы хотите перейти, Chrome заранее подгружает ресурсы в кеш (тема кеша выходит за рамки моего повествования), еще до того как вы нажали на Enter.
3)	Prerendering (предварительная отрисовка сайта)
Chrome может предварительно рендерить (отрисовывать) страницы, которые, скорее всего, будут посещены вами, основываясь на предыдущих паттернах вашего поведения, истории и бог весть чего еще. 

Обычно мы вводим название сайта без указания протокола и номера порта. Браузер же сам, по умолчанию в качестве протокола подставляет HTTPS и порт 443. Если запрашиваемый сайт не поддерживает HTTPS, то произойдет падение до HTTP и соответствеенно прота 80.
Кстати, если вы уже ранее заходили на сайт, используя HTTPS, то браузер запоминает это и в последующие разы тоже будет подключаться по HTTPS. Этот механизм запоминания, хранения и использования этой информации о пртоколе подключения называется HSTS (HTTP Strict Transport Security) и по сути является жестким указанием сервера, на котором находится веб сайт, всегда подключаться к нему используя только HTTPS. Данный механизм способствует повышению безопасности и помогает защититься от атак типа Man-in-the-middle, и браузер, однажды получив такое указание от сервера, уже не может так просто понизить протокол до HTTP (объяснение немного грубое, но суть в этом)

Вообще браузер Chrome поддерживает такие протоколы как http, https, file (чтобы например открыть файл с локального компа), ftp (чтобы например скачать файл с ftp сервера), chrome (для доступа к скрытым настройкам браузера), mailto (для отправки почты с локального клиента, типа Microsoft Outlook, Thunderbird и т.п.)
Насколько я знаю Chrome, Firefox и некоторые другие браузеры не так давно отказались от поддержки FTP, полностью выпилив его из кодвой базы. Но если вы пользуетесь данным протоколом, то вероятно используете более удобный софт наподобие FileZilla и т.п., так что невелика потеря. Далее, дабы не уходить в дебри, в качестве протокола подключения к сайту будем обсуждать  только HTTP и HTTPS, оставив остальные протоколы за скобками. 

Итак, наконец то мы ввели наш URL xss.is, браузер автоматически подставил протокол HTTPS и порт 443 и у нас высветилось  https://xss.is (по умолчанию он не прописывает порт в адресной строке, но так как выбранный протокол в данном случае – HTTPS, то порт по умочанию используется 443. То же самое в случае выбора HTTP. Если порт для подключения не стандартный (а такое может быть, если админ веб-сайта под солями), то можно ввести его вручную через символ «:», например вот так https://xss.is:228)

Кстати вся строка https://xss.is называется URL (uniform resource locator, универсальный локатор ресурса), http – называется scheme (схема) и определяет протокол доступа к сайту, xss.is – это имя хоста, конкретно xss – это домен второго уровня, is – домен первого уровня. И в конце адреса https://xss.is символ обычной точки “.”, но ее не принято указывать. Она символизирует корневой DNS домен (о нем и вообще о DNS будет далее).

Для общего развития давайте введем еще темин FQDN, так как он часто используется в литературе и при настройках различных веб-сервисов.
FQDN (Fully Qualified Domain Name) — это полное доменное имя, которое определяет точное местоположение узла в иерархии доменной системы имен (DNS). FQDN включает в себя все уровни доменного имени, начиная с конкретного узла (имя хоста) и заканчивая корневым доменом, который, как я и писал ранее, обычно обозначается точкой «.» и частенько не указывается. 
Например: xss.is. – это FQDN, заметьте, что здесь стоит точка в конце, так как только такая запись счиатется технически правильной и используется в документации и периодически при конфигурации DNS серверов. Но правила созданы, для того чтобы их нарушать, так что в больштнстве случаев точка идет на..й.

				DNS resolving

Но вернемся к нашей адресной строке и нажмем ENTER.
Если до этого мы говорили в основном про то что происходит внутри браузера, то теперь нам необходимо проследить весь путь нашего запроса по так называемой модели OSI (полагаю что читатель представляет что это, а если нет то Google в помощь). 
Я снова надеюсь что уважаемый читатель знает, что все компухтеры в этих ваших интернетах имеют так называемый IP-адрес (набор цифр типо 37.187.25.182). Если привести аналогию, то IP-адрес, это как название города, номер дома и квартиры, которые указывает военком на повестке, когда отправляет ее вам по адресу вашей прописки. 
Но мы же ввели в адресной строке НЕ набор цифр 37.187.25.182, а строку текста https://xss.is. Так как браузер узнает на какой именно сервер отправить наш запрос (на получение контента веб-страницы)? Вот как раз тут с обеих ног и врывается DNS. 

DNS (Domain Name System) — это система доменных имен, используемая для преобразования доменных имен, которые легко запоминаются людьми, в IP-адреса, которые используются компьютерами для идентификации узлов в сети. Проще говоря, DNS действует как "телефонная книга" интернета, связывая доменные имена (например, xss.is) с их соответствующими IP-адресами (например, 37.187.25.182). 
Где же хранится эта «телефонная книга»? На множестве компьютеров (серверов) в интеренете называемых DNS-сервера и имеющих иерархическую структуру в виде дерева или скорее куста (не того, о котором вы подумали грязные извращенцы), где начальной точкой из которой растут все ветки, является тот самый корневой DNS сервер (root server), та самая «.», которую мы уже не ставим в коце URL’а. Этот DNS сервер хранит только ip адреса серверов первого уровня, их еще называют домены верхнего уровня (top levels domains). Это всем известные ru, com, org, is и многие другие. Они хранят  ip адреса только доменов второго уровня, например wikipedia, pornhub, yandex и наш xss. Именно имя домена второго уровня вы можете купить у провайдеров преоставляющих услуги по продаже доменных имен и выбрать зону из доменов первого уровня. Например название домена нашего сайта мы придумали XSS (можно придумать любое), и хотим чтобы он был привязан к зоне IS. В итоге наш URL теперь https://xss.is. Оплачиваем от 2 и более американчких рублей и домен наш. Теперь имея этот домен в совем распоряжении мы можем привязать ip адрес своего сервера, на котором хостится (живет) наш сайт, к данному доменному имени через личный кабинет DNS-сервера. Теперь данный  DNS сервер хранит первичную запись соответствия: ip адрес – имя домена. Для справки данный сервер называется авторитетный сервер (authoritative server) или часто NS-сервер (name server). 
Кстати теперь мы можем создать не один веб сайт, расположенный на домене xss.is, а несколько, но тогда их имя должно включать в себя домен третьего уровня, например:
shop.xss.is – для допутстим интернет-магазина, forum.xss.is – для форума, porn.xss.is – для хранения и онлайн просмотра домашнего видеоконтента, ну вы поняли. И за это уже не надо никому платить. Вы один раз покупаете домен второго уровня, а все уровни выше уже оплачивать не надо. 
Но мы немного от отклонились от темы. Итак, мы ввели xss.is, и нажали ENTER. Браузер автоматически подставил протокол https и порт (мы его не видим в адресной строке, но он есть, без него никак). Далее как раз и происходит так называемое разрешение доменного имени в IP-адрес» (resolving), конечным результатом которого является получение IP-адреса нашего сайта, указания его в качестве адреса назначения в IP-пакете и отправка далее в интернет.
Как происходит это разрешение доменного имени в ip-адрес? 
Если сильно упростить, то браузер делает так называемый DNS запрос на 53 порт DNS  сервера, IP адрес которого указан в настройках вашей сетевой карты. Обычно это IP адрес вашего роутера.  Далее ваш роутер пересылает запрос на DNS адрес вашего провайдера, который в свою очередь пересылает запрос по цепочке далее к другим DNS серверам пока не получит в ответ IP адрес сайта. 
Такой ответ устроит собеседующего разве что, если вы собеседуетесь на должность эникея (младший сисадмин). В идеале DNS запрос следует описать более подробно.

После нажатия клавиши ENTER, браузер ищет соответствие имени введенного сайта IP-адресу в свое кеше браузера. Данный кеш хранится в оперативной памяти пока браузер работает, и стирается после закрытия браузера. Принудительно стереть его можно введя в адресной строке chrome://net-internals/#dns и после  нажав на кнопку  Clear host cache. 
Если браузер не нашел в своем кеше требуемый IP, то он обращается к текстовому файлу host. На Windows он лежит по пути C:\Windows\System32\drivers\etc\host.
Данный файл присутствует в каждой ОС и является обычным текстовым (.txt) файлом содержащим строчки соответствия доменного имени IP-адресу. Например : 127.0.0.1   localhost. Данный файл в настоящее время утратил ту функцию, ради которой он был создан, а именно выполнение dns resolving’а. Так как в на точке время эту функцию выполняют DNS сервера, которых не было на момент создания этого файла. Сейчас он используется например в тестировании и разработке для тестирования веб-сайтов на локальной машине до размещения их в открытом интернете. 
После того как система обратилась к этому файлу и не нашла ip адрес для доменного имени xss.is, она она ищет его уже в своем кеше ОС. На Windows посмотреть его можно командой ipconfig /displaydns , а стереть ipconfig /flushdns. 
Не надя ip адрес там, ОС обращается к DNS серверу, ip адрес которого прописан в настройках нашего сетевого адаптера. Обычно это ip адрес нашего роутера, но может быть и ip конкретного dns, например всем известный гугловский 8.8.8.8. Рассмотрим пример когда в настройках прописан ip роутера, например 192.168.1.1. Запрос всегда идет на порт 53 dns сервера с любого динамически (рандомно) выбираемого порта (ответ соответственно приходит с 53 порта сервера на тот порт на локальной машине, с которого пришел запрос) Получив dns запрос с просьбой найти ip адрес xss.is, наш роутер ищет его в своем кеше. Не найдя в своем кеше, роутер делает запрос на DNS сервер нашего провайдера (или любой другой DNS сервер указанный в настройках нашего роутера, например 8.8.8.8). И так далее по цепочке запрос идет до того DNS сервера, который имеет инфу о соответствии имени ip адресу.
В данной цепочке запросов существует такие понятия как рекурсивный и итерационный запрос. Но различия этих запросов мы опустим, так как конечный результат для нас один и тот же – мы получаем ip  адрес для дмоена xss.is. Просто имейте ввиду, что при собеседовании на должность сетевого администратора с вас потребуют знание отличия рекурсивного от итерационного запросов.  
Теперь браузер знает ip адрес сайта и происходит подключение. В процессе подключения незаметно для нас осуществляется несколько этапов таких как
Установление TCP-подключения: Браузер и сервер выполняют трехстороннее рукопожатие для установления TCP-подключения.
Установление TLS-соединения: Браузер и сервер выполняют TLS-рукопожатие для создания защищенного соединения, включая обмен сертификатами и установление шифрованного канала.
Отправка HTTP-запроса: Браузер отправляет HTTP-запрос через защищенный TLS-канал.
Получение HTTP-ответа: Сервер обрабатывает запрос и отправляет HTTP-ответ обратно через тот же защищенный канал.
Когда браузер получил HTML код, он, а точнее его движек рендеринга начинает парсить полученный HTML код, создавая так называемые узлы для каждого элемента, а эти узлы организуются в DOM-дерево (document object model - иерархическая структура, которая описывает содержимое HTML документа)
Далее браузер парсит CSS и создает CSSOM-дерево, отражающее все стили страницы
Далее идет слияние DOM и CSSOM, создается  грубо говоря макет страницы.
Одновременно с этими процессами  отрабатывает javascript движек браузера и вносит правки в этот макет. В конце концов браузер отрисовывает страницу основываясь на макете, в результате чего мы можем созерцать запрошенную нами страницу веб-сайта.



Установление TLS соединения (HTTPS)
1. Клиент запрашивает публичный ключ у сервера, отсылая hello сообщение 
2. Сервер отправляет клиенту свой публичный ключ (это называется - сертификат, подписанный ЦС)
Чтобы ЦС выдал такой сертификат серверу, сервер должен заранее предоставить ЦС необходимые данные владельца сервера (имя, паспорт, доказательства что сервер именно его), и после этого ЦС выдаст серверу сертификат (т.е. ЦС прикрепляет к публичному ключу сервера данные, что это именно этот сайт и шифрует эти данные своим приватным ключом - это называется сертификат подписанный ЦС)
3. Клиенту нужно убедиться что этот сертификат, полученный от сервера, принадлежит именно этому серверу, поэтому он расшифровывает этот Сертификат с помощью публичного ключа от ЦС, который встроен в браузер. Он встраивается на этапе установки браузера и хранится там всегда.
Это немножко странно, что корневой ЦС шифрует сообщение своим приватным ключом и его можно расшифровать с помощью публичного ключа - обычно наоборот, но именно так работает электронная подпись (если мы можем расшифровать сообщение публичным ключом корневого ЦС, то мы точно знаем что оно было подписано с помощью его привтного ключа.)
- Созыкин в этом видео https://youtu.be/6wCwjIhGylY говорит, что при установке ОС в спец хранилище устанавливаются публичные ключи корневого ЦС, и клиент при проверке сертификата, полученного от сервера (сайта) идёт по цепочке доверия и проверяет сначала публичный ключ ЦС, а затем публичный ключ корневого ЦС, который выдал сертификат этому ЦС.
Если пришедший от сайта публичный ключ (сертификат) не подписан, то в браузере вылезает сообщение «Вы уверены что хотите принять этот публичный ключ?»
А может быть, что сертификат подписан (например самоподписанный), но браузер не знает кем. Тогда тоже выходит сообщение. Самоподписанные сертификаты - это такие же сертификаты, они безопасные и могут использоваться внутри корпоративной структуры для шифрования трафика, так как в ней мы априори доверяем друг другу.
4. Теперь клиент уверен, что он общается именно с сайтом с которым хотел общаться. Клиент шифрует симметричный (сессионный) ключ публичным ключом сервера и отправляет на сервер
5. Сервер расшифровывает это сообщение с помощью своего приватного ключа. Таким образом получая сессионный ключ.
6. Теперь сервер и клиент могут шифровать сообщения друг другу этим симметричным сессионным ключом. Это требует меньших мощностей, чем если бы они использовали публичные (ассиметричные) ключи друг друга. 

https://doka.guide/tools/ssl-certificates/

В основном браузеры не имеют собственного хранилища сертификатов и доверяют хранилищу Windows, однако Firefox имеет свое хранилище, независимое от системного. 

Публичный и приватный ключ - это ассиметричное шифрование.  Так как ключи разные. 


- Когда браузер получил HTML код, он (движек рендеринга) начинает парсить его (HTML код), создавая так называемые узлы для каждого элемента, а эти узлы организуются в DOM-дерево (document object model - иерархическая структура, которая описывает содержимое HTML документа)
- Далее браузер парсит CSS и создает CSSOM-дерево, отражающее все стили страницы
- Далее идет слияние DOM и CSSOM, создается типо макет страницы
- Одновременно (?) отрабатывает javascript движек браузера и вносит правки в макет
- Браузер отрисовывает страницу основываясь на макете

Вышеописанный парсинг делается в несколько проходов, а не просто сверху-вниз или снизу-вверх, то есть парсинг там довольно сложный

      Электронная подпись (как ЦС подписывает серт сервера)

При использовании электронной подписи мы не шифруем содержимое документа. Вместо этого мы создаем цифровую подпись, которая добавляется к документу и служит для проверки его подлинности и целостности. Вот как это работает:

### Процесс создания электронной подписи:

1. **Хэширование**: Сначала вычисляется хэш (дайджест) документа с использованием криптографической хэш-функции (например, SHA-256). Хэш-функция преобразует документ в фиксированной длины строку (хэш-значение), которая уникальна для каждого уникального документа.

2. **Шифрование хэша**: Затем этот хэш шифруется с использованием приватного ключа отправителя. Это зашифрованное хэш-значение и есть цифровая подпись.

3. **Присоединение подписи**: Цифровая подпись присоединяется к документу. Документ вместе с цифровой подписью отправляется получателю.

### Процесс проверки электронной подписи:

1. **Расшифрование хэша**: Получатель использует публичный ключ отправителя, чтобы расшифровать цифровую подпись, получив тем самым оригинальное хэш-значение, которое было зашифровано отправителем.

2. **Хэширование документа**: Получатель вычисляет хэш-значение полученного документа с использованием той же хэш-функции, что и отправитель.

3. **Сравнение хэшей**: Если вычисленный хэш совпадает с расшифрованным хэш-значением, это подтверждает, что документ не был изменен и действительно был подписан отправителем.

### Резюме:
- **Электронная подпись**: Она не шифрует весь документ, а только хэш-значение документа с использованием приватного ключа. Подпись служит для проверки подлинности и целостности документа.
- **Цель**: Подтвердить, что документ был создан (или подписан) определенным лицом (обладателем приватного ключа) и что его содержимое не изменялось с момента подписания.

Таким образом, цифровая подпись гарантирует, что документ является подлинным и не был изменен, но сам документ не шифруется в процессе подписания.


            Пример итеративного запроса, чтобы разрешить домен yura.it-website.online в ip адрес

nslookup -type=ns . - разрешаем список ns серверов зоны . , а в ответ получаем список DNS серверов обслуживающих эту зону
      (root)  nameserver = l.root-servers.net
      (root)  nameserver = b.root-servers.net
      (root)  nameserver = d.root-servers.net
      (root)  nameserver = e.root-servers.net
      (root)  nameserver = k.root-servers.net
      (root)  nameserver = j.root-servers.net
      (root)  nameserver = c.root-servers.net
      (root)  nameserver = f.root-servers.net
      (root)  nameserver = a.root-servers.net
      (root)  nameserver = g.root-servers.net
      (root)  nameserver = m.root-servers.net
      (root)  nameserver = i.root-servers.net
      (root)  nameserver = h.root-servers.net

Теперь у любого из этих серверов спрашиваем кто обслуживает зону .ru:
nslookup -type=ns ru a.root-servers.net
      ru      nameserver = a.dns.ripn.net
      ru      nameserver = d.dns.ripn.net
      ru      nameserver = f.dns.ripn.net
      ru      nameserver = b.dns.ripn.net
      ru      nameserver = e.dns.ripn.net
      a.dns.ripn.net  internet address = 193.232.128.6
      a.dns.ripn.net  AAAA IPv6 address = 2001:678:17:0:193:232:128:6
      d.dns.ripn.net  internet address = 194.190.124.17
      d.dns.ripn.net  AAAA IPv6 address = 2001:678:18:0:194:190:124:17
      f.dns.ripn.net  internet address = 193.232.156.17
      f.dns.ripn.net  AAAA IPv6 address = 2001:678:14:0:193:232:156:17
      b.dns.ripn.net  internet address = 194.85.252.62
      b.dns.ripn.net  AAAA IPv6 address = 2001:678:16:0:194:85:252:62
      e.dns.ripn.net  internet address = 193.232.142.17
      e.dns.ripn.net  AAAA IPv6 address = 2001:678:15:0:193:232:142:17

В ответ получаем список серверов и их ip

По аналогии дальше:
nslookup -type=ns it-website.ru a.dns.ripn.net

      IT-WEBSITE.ru   nameserver = ns2.reg.ru
      IT-WEBSITE.ru   nameserver = ns1.reg.ru
      ns2.REG.RU      internet address = 176.99.13.12
      ns2.REG.RU      internet address = 176.99.13.14
      ns2.REG.RU      internet address = 176.99.13.16
      ns2.REG.RU      internet address = 176.99.13.18
      ns2.REG.RU      internet address = 194.58.117.12
      ns2.REG.RU      internet address = 194.58.117.14
      ns2.REG.RU      internet address = 194.58.117.16
      ns2.REG.RU      internet address = 194.58.117.18
      ns2.REG.RU      internet address = 194.67.73.175
      ns2.REG.RU      internet address = 194.67.73.176
      ns1.REG.RU      internet address = 176.99.13.11
      ns1.REG.RU      internet address = 176.99.13.13
      ns1.REG.RU      internet address = 176.99.13.15
      ns1.REG.RU      internet address = 176.99.13.17
      ns1.REG.RU      internet address = 194.58.117.11
      ns1.REG.RU      internet address = 194.58.117.13
      ns1.REG.RU      internet address = 194.58.117.15
      ns1.REG.RU      internet address = 194.58.117.17
      ns1.REG.RU      internet address = 194.67.73.173
      ns1.REG.RU      internet address = 194.67.73.174
      ns2.REG.RU      AAAA IPv6 address = 2a00:f940:5::190
      ns1.REG.RU      AAAA IPv6 address = 2a00:f940:4::47

Теперь, так как мы нашли кто отвечает за нужную нам зону, то запрашиваем A запись
nslookup -type=a it-website.ru ns1.reg.ru
      Name:    it-website.ru
      Address:  89.107.10.136
